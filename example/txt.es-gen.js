// Resource group file generated by emery-spinner, don't edit outside JSON part below
_EmerySpinnerRuntime_.addResources(
//--edit-below-json-only-utf8-<
{
	"#L@/txt/?rSEHK12mC": {
		"_hint": "rSEHK12mC",
		"@type": "localized_string",
		"ru": "Приветствуем в демо-примере ES, локализация=ru",
		"en": "Hello in ES example demo program, locale=en",
		"tr": "Merhaba ES örnek demo programında, locale=tr"
	},
	"#L@/txt/untranslated": {
		"_hint": "b4QCoX8WQ",
		"@type": "localized_string",
		"ru": "<UNTRANSLATED>This message is intentionally left untranslated",
		"en": "<LOCALE_ORG_HINT>This message is intentionally left untranslated",
		"tr": "<UNTRANSLATED>This message is intentionally left untranslated"
	},
	"#L@/txt/?tZKPbxKf9": {
		"_hint": "tZKPbxKf9",
		"@type": "localized_string",
		"ru": "Участвуют тайлы:",
		"en": "Featuring tiles:",
		"tr": "Fayanslar:"
	},
	"#L@/txt/?1O4ChJN1g": {
		"_hint": "1O4ChJN1g",
		"@type": "localized_string",
		"ru": "пустой = %0%",
		"en": "blank = %0%",
		"tr": "boş = %0%"
	},
	"#L@/txt/?8tzvuNASQ": {
		"_hint": "8tzvuNASQ",
		"@type": "localized_string",
		"ru": "крестик = %0%",
		"en": "cross = %0%",
		"tr": "çapraz = %0%"
	},
	"#L@/txt/?VR4m94Q2L": {
		"_hint": "VR4m94Q2L",
		"@type": "localized_string",
		"ru": "кирпич = %0%",
		"en": "brick = %0%",
		"tr": "tuğla = %0%"
	},
	"#L@/txt/?YbqwyS2AK": {
		"_hint": "YbqwyS2AK",
		"@type": "localized_string",
		"ru": "точка = %0%",
		"en": "dot = %0%",
		"tr": "nokta = %0%"
	},
	"#L@/txt/?S5PK4EG36": {
		"_hint": "S5PK4EG36",
		"@type": "localized_string",
		"ru": "...и другие",
		"en": "...and others",
		"tr": "...ve diğerleri"
	},
	"#L@/txt/algo-desc": {
		"_hint": "G61vM3oaa",
		"@type": "localized_string",
		"ru": "Алгоритм размещения заданного числа одинаковых тайлов n1, n2,...nN на сетке размера W*H, где W, H - степени двойки. Размещение рандомизированное, но, по возможности, пытающееся соблюдать принципы симметрии.\n0. Если n1=n2=...=nN=0, то тривиальный случай - просто пустая сетка размером W*H, заполняем её пустотой, и на этом заканчиваем.\n1. Строим список возможных опций:\n1.1. Если W>1, и n1...nN - чётные, возможна опция \"симметризация по вертикали\": рекурсивно применить алгоритм для левой половины доски с W'=W/2, n1'=n1/2,...nN'=nN/2, а правую получить вертикальным отражением левой.\n1.2. Если H>1, и n1...nN - чётные, возможна опция \"симметризация по горизонтали\": рекурсивно применить алгоритм для верхней половины доски с H'=H/2, n1'=n1/2,...nN'=nN/2, а нижнюю получить вертикальным отражением верхней.\n1.3 Если W>1, H>1, и n1...nN делятся на 4, возможна опция \"симметризация по обоим направлениям\": рекурсивно применить алгоритм для верхней левой половины доски с H'=H/2, W'=W/2, n1'=n1/4,...nN'=nN/4, а остальные 3 получаем её зеркальными отображениями в соответствующих направлениях.\n2. Если полученный список опций не пуст, случайно выбираем опцию, выполняем её и заканчиваем. Если же список опций пуст, но W>1 или H>1, и при этом хотя бы один из n1...nN больше нуля, то:\n3. Разделяем n1...nN на два массива - n1_1~n1/2,...nN_1~nN/2, и n1_2~n1/2,...nN_2~nN/2 (ni_1, ni_2 по возможности равны ni/2, если же ni нечётное, лишняя единица докидывается в случайно выбранный из двоих, по возможности так, чтобы n1_1+...+nN_1 <= W*H/2 и n1_2+...+nN_2 <= W*H/2).\n4. Строим список возможных опций выбора раздельного заполнения:\n4.1. Если W>1, возможна опция \"разделение по вертикали\": рекурсивно применяем алгоритм для левой половины с W'=W/2, n1=n1_1,...nN=nN_1, и для правой половины с W'=W/2, n1'=n1_2,...nN'=nN_2.\n4.2. Если H>1, возможна опция \"разделение по горизонтали\": рекурсивно применяем алгоритм для верхней половины с H'=H/2, n1'=n1_1,...nN'=nN_1, и для нижней половины с H'=H/2, n1'=n1_2,...nN'=nN_2.\n(Опцию \"разделение по 4 направлениям\" не рассматриваем, т. к. у нас всё равно случай, когда симметрию на всей исходной площади соблюсти не удалось, так что усложнять ни к чему.)\n5. Если полученный список опций не пуст, случайно выбираем опцию, выполняем её и заканчиваем.\n6. Если же и этот список пустой, то делать нечего - заполняем сетку заданным количеством тайлов случайным образом.",
		"en": "An algorithm for placing a given number of identical tiles n1, n2,...nN on a grid of size W*H, where W, H are powers of two. The placement is randomized, but, if possible, trying to respect the principles of symmetry.\n0. If n1=n2=...=nN=0, it is the trivial case, simply an empty grid of size W*H, fill it with emptiness, and finish.\n1. Construct a list of possible options:\n1.1. If W>1, and n1...nN are even, the \"vertical symmetrization\" option is possible: recursively apply the algorithm to the left half of the board with W'=W/2, n1'=n1/2,...nN'=nN/2, and obtain the right half by a vertical reflection of the left half.\n1.2. If H>1, and n1...nN are even, the option \"horizontal symmetrization\" is possible: recursively apply the algorithm for the upper half of the board with H'=H/2, n1'=n1/2,...nN'=nN/2, and obtain the lower half by vertical reflection of the upper one.\n1.3. If W>1, H>1, and n1...nN are divisible by 4, the option \"symmetrization in both directions\" is possible: recursively apply the algorithm for the upper left half of the board with H'=H/2, W'=W/2, n1'=n1/4,...nN'=nN/4, and the other 3 are obtained by its mirror images in the corresponding directions.\n2. If the resulting list of options is not empty, we randomly choose an option, execute it, and finish. If the option list is empty, but W>1 or H>1, and at least one of n1...nN is greater than zero, then:\n3. Partition n1...nN into two arrays - n1_1~n1/2,...nN_1~nN/2, and n1_2~n1/2,.... nN_2~nN/2 (ni_1, ni_2 are equal to ni/2 if possible, and if ni is odd, an extra unit is added to a randomly chosen one of the two, in such a way, if possible, that n1_1+...+nN_1 <= W*H/2 and n1_2+...+nN_2 <= W*H/2).\n4. Construct a list of possible options for selecting split filling:\n4.1. If W>1, the \"vertical split\" option is possible: we recursively apply the algorithm for the left half with W'=W/2, n1'=n1_1,...nN'=nN_1, and for the right half with W'=W/2, n1'=n1_2,...nN'=nNN_2.\n4.2. If H>1, the option \"split horizontally\" is possible: recursively apply the algorithm for the top half with H'=H/2, n1'=n1_1,...nN'=nN_1, and for the bottom half with H'=H/2, n1=n1_2,...nN=nNN_2.\n(We do not consider the option \"division along 4 directions\", since we are at a case when symmetry on the whole initial area could not be satisfied, so there is no need to complicate it anyway).\n5. If the obtained list of options is not empty, we randomly select an option, execute it and finish.\n6. If this list is empty, there is nothing to do - fill the grid with a given number of tiles randomly.",
		"tr": "Belirli sayıda n1, n2,...nN özdeş karoyu W*H boyutunda bir ızgara üzerine yerleştirmek için bir algoritma, burada W, H ikinin dereceleridir. Yerleştirme rastgele yapılır, ancak mümkünse simetri ilkelerine uyulmaya çalışılır.\n0. Eğer n1=n2=...=nN=0 ise, o zaman önemsiz durum basitçe W*H boyutunda boş bir ızgaradır, onu boşlukla doldururuz ve bir gün olarak adlandırırız.\n1. Olası seçeneklerin bir listesini oluşturun:\n1.1. W>1 ve n1...nN çift ise, \"dikey simetrizasyon\" seçeneği mümkündür: algoritmayı W'=W/2, n1'=n1/2,...nN'=nN/2 ile tahtanın sol yarısına özyinelemeli olarak uygulayın ve sol yarının dikey yansımasıyla sağ yarıyı elde edin.\n1.2. H>1 ve n1...nN çift ise, \"yatay simetrizasyon\" seçeneği mümkündür: H'=H/2, n1'=n1/2,...nN'=nN/2 ile tahtanın üst yarısı için algoritmayı özyinelemeli olarak uygulayın ve üst yarının dikey yansımasıyla alt yarıyı elde edin.\n1.3. W>1, H>1 ve n1...nN 4'e bölünebiliyorsa, \"her iki yönde simetri\" seçeneği mümkündür: H'=H/2, W'=W/2, n1'=n1/4,...nN'=nN/4 ile tahtanın sol üst yarısı için algoritmayı özyinelemeli olarak uygulayın ve diğer 3'ü ilgili yönlerdeki ayna görüntüleri ile elde edilir.\n2. Elde edilen seçenek listesi boş değilse, rastgele bir seçenek seçer, çalıştırır ve bitiririz. Seçenekler listesi boşsa, ancak W>1 veya H>1 ise ve n1...nN'den en az biri sıfırdan büyükse, o zaman:\n3. n1...nN'yi iki diziye bölün - n1_1~n1/2,...nN_1~nN/2 ve n1_2~n1/2,..... nN_2~nN/2 (ni_1, ni_2 mümkünse ni/2'ye eşittir ve ni tek ise, mümkünse ikisinden rastgele seçilen birine fazladan bir birim eklenir, böylece n1_1+...+nN_1 <= W*H/2 ve n1_2+...+nN_2 <= W*H/2 olur).\n4. Bölünmüş dolguyu seçmek için olası seçeneklerin bir listesini oluşturun:\n4.1. W>1 ise, dikey bölme seçeneği mümkündür: algoritmayı W'=W/2, n1=n1_1,...nN=nN_1 ile sol yarı için ve W'=W/2, n1'=n1_2,...nN'=nN_2 ile sağ yarı için özyinelemeli olarak uygularız.\n4.2. H>1 ise, \"yatay olarak bölme\" seçeneği mümkündür: algoritmayı H'=H/2, n1'=n1_1,...nN'=nN_1 ile üst yarı için ve H'=H/2, n1'=n1_2,...nN'=nN_2 ile alt yarı için özyinelemeli olarak uygulayın.\n(\"4 yön boyunca bölme\" seçeneğini dikkate almıyoruz, çünkü tüm başlangıç alanında simetrinin zaten gözlemlenemediği bir durumumuz var, bu yüzden karmaşıklaştırmaya gerek yok).\n5. Elde edilen seçenekler listesi boş değilse, rastgele bir seçenek seçer, yürütür ve bitiririz.\n6. Bu liste boşsa, yapacak bir şey yoktur - ızgarayı belirli sayıda taşla rastgele doldurun."
	},
	"#L@/txt/?RvBPoZ11C": {
		"_hint": "RvBPoZ11C",
		"@type": "localized_string",
		"ru": "Пример для: %0%",
		"en": "Example for: %0%",
		"tr": "Şunun için örnek: %0%"
	}
}
//>--edit-above-json-only-utf8
);
// TODO: progress indicator
_EmerySpinnerRuntime_.asyncRemoveCurrentScript();