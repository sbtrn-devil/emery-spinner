var { DepGraph } = require('./depgraph.js'),
	{ DepTaskDoer } = require('./deptaskdoer.js'),
	{ readJSFile } = require('./js-reader.js'),
	{ WrappedJSON } = require('./wrapped-json.js'),
	{ Filework } = require('./filework.js'),
	{ Future } = require('./future.js'),
	{ openClient } = require('./subprocess.js'),
	iconvlite = require('iconv-lite'),
	njsPath = require('path'),
	njsFs = require('fs'),
	util = require('util');

const
	REGEXP_SOURCE_TAG = /<!--\s*#emery-target\s*-->/,
	REGEXP_PREFIX = /(^[-_.A-Za-z]+:)(.*)$/,
	REGEXP_RESREF = /^#([-A-Za-z0-9._\(\)\[\]\{\}$%!]+)@/,
	REGEXP_GROUP_FILE_BASENAME = /^(\/.*)?(?:\.es-gen\.js)?$/i,
	ITEM_FILE_PREFIX = "file:",
	ITEM_JS_PREFIX = "js:",
	ITEM_RAWJS_PREFIX = "rawjs:",
	ITEM_ROOT_PREFIX = "root:",
	ITEM_TOOL_PREFIX = "tool:",
	ITEM_TOOLCFG_PREFIX = "tool-cfg:",
	ITEM_RES_PREFIX = "res:",
	ITEM_RESGRP_PREFIX = "res-grp:",
	ITEM_LINKSJS_PREFIX = "links-js:",
	ITEM_SOURCEHTML_PREFIX = "source-html:",
	ITEM_TARGETHTML_PREFIX = "target-html:",
	
	LINKSJS_NODE_ID = ITEM_LINKSJS_PREFIX + "links",
	SOURCEHTML_NODE_ID = ITEM_SOURCEHTML_PREFIX + "source",
	TARGETHTML_NODE_ID = ITEM_TARGETHTML_PREFIX + "target";

const linksWrappedJSON = WrappedJSON({
		prologue: "// Links file generated by emery-spinner, don't edit\n" +
			"_EmerySpinnerRuntime_.loadLinks(",
		beginFragment: "//--json-array-<",
		endFragment: "//>--json-array",
		epilogue: ");\n// TODO: progress indicator"
	});

function arrayEquals(a, b) {
	return Array.isArray(a) &&
		Array.isArray(b) &&
		a.length === b.length &&
		a.every((val, index) => val === b[index]);
}

function setEquals(a, b) {
	for (var ina of a) {
		if (!b.has(ina)) return false;
	}
	for (var inb of b) {
		if (!a.has(inb)) return false;
	}
	return true;
}

function jsonEquals(a, b) {
	if (a === b) return true;
	if (typeof(a) !== 'object' || typeof(b) !== 'object') {
		return a === b;
	}
	for (var k in a) {
		var v = a[k];
		if (v === undefined) continue; // ignore undefineds
		if (!(k in b)) return false;
		if (!jsonEquals(v, b[k])) return false;
	}
	for (var k in b) {
		var v = b[k];
		if (v === undefined) continue; // ignore undefineds
		if (!(k in a)) return false;
		if (!jsonEquals(v, a[k])) return false;
	}
	return true;
}

function toFuckingInt(a) {
	return a ? (typeof(a == 'number')? Math.floor(a) : (parseInt(a.toString()) || 0)) : 0;
}

function parseNodeId(nodeId) {
	var match = nodeId.match(REGEXP_PREFIX);
	if (match) {
		return [match[1], match[2]];
	}
}

exports.Framework = function Framework(rootFilePath) {
	if (new.target) return Framework(rootFilePath);

	var me,
		noStdErr = false,
		logFileStream = null,
		logFileStreamPath,
		depGraph = new DepGraph(),
		depTaskDoer = new DepTaskDoer(),
		rootFileName = njsPath.basename(rootFilePath),
		rootDir = njsPath.dirname(rootFilePath),
		rootProjPath = "/" + rootFileName,
		rootProjPathNoExt = "/" + njsPath.basename(rootFilePath, ".js"),
		filework = new Filework(rootFilePath),
		extraNodesToCheckOnNextPerform = new Set(),
		toolByResType = new Object(),
		toolsCurrentCfg = new Object(),
		rootCfg = {
			"source": rootProjPathNoExt + ".src.html", // proj file path of the source template (.src.html)
			"target": rootProjPathNoExt + ".dbg.html", // proj file path of the target html (.dbg.html)
			"release-target": rootProjPathNoExt + ".html", // proj file path of the target amalgamated release html (.html)
			"links-js": rootProjPathNoExt + "-links-noed.es-gen.js", // proj file path of the generated ESpin links JS (links to the affected JS files to load, in the order)
			"default-resgroup-js": rootProjPathNoExt + "-defres.es-gen.js" // proj file path of the generated default resource group file
		},
		rootFilework = filework.pathGetterRelToProjFilePath(rootProjPath),
		needResetProjTargetNodes = true,
		resGroupNodeIds = new Set(),
		jsNodeIds = new Set(),
		toolNodeIds = new Set(),
		nodeIdsDeletedThisRespin = new Set(),
		nodeCheckTasks = new Object(), // by node ID
		debugOns = new Object(), // source => bool
		itemsInError = new Map(),
		toolNodesInBuildTest = new Set(),
		resScansSkippedForBuildTest = new Set(),
		resNodesToRecheckAfterBuildTest = new Set(),
		spTool = null; // subprocess

	// loggers

	function logErrorWithSource(source, data, ...args) {
		var msg = util.format(data, ...args);
		(noStdErr ? console.log : console.error)(data, ...args);
		if (logFileStream) {
			logFileStream.write(msg);
			logFileStream.write("\n");
		}
	}

	function logInfoWithSource(source, data, ...args) {
		var msg = util.format(data, ...args);
		console.log(msg);
		if (logFileStream) {
			logFileStream.write(msg);
			logFileStream.write("\n");
		}
	}

	function logDebugWithSource(source, data, ...args) {
		if (debugOns[source]) {
			var msg = util.format(data, ...args);
			console.log(msg);
			if (logFileStream) {
				logFileStream.write(msg);
				logFileStream.write("\n");
			}
		}
	}

	function logError(data, ...args) {
		logErrorWithSource("", data, ...args);
	}

	function logInfo(data, ...args) {
		logInfoWithSource("", data, ...args);
	}

	function logDebug(data, ...args) {
		logDebugWithSource("", data, ...args);
	}

	// node management helpers

	function nodeExists(nodeId) {
		return depGraph.getNodeIfExists(nodeId) != null;
	}

	function getNodeIfExists(nodeId) {
		return depGraph.getNodeIfExists(nodeId);
	}

	function genGetNode(type, setuper) {
		return (function getNode(itemId) {
			var node = depGraph.getNode(itemId);
			if (!node.data.type) {
				node.data.type = type;
				node.data.rebuildCause = "Item discovered";
				setuper(node, itemId);
			}
			return node;
		});
	}

	const getFileNode = genGetNode("file", (node) => {
		if (!node.id.startsWith(ITEM_FILE_PREFIX)) {
			throw new Error("Raw file resource " + node.id + " does not start with " + ITEM_FILE_PREFIX);
		}
		node.data.fileProjPath = node.id.substring(ITEM_FILE_PREFIX.length);
		node.data.filePath = filework.projectPathToRealPath(node.data.fileProjPath);
		node.setTerminal();
	});

	const getJSFileNode = genGetNode("js", (node) => {
		// js item ID is "js:" + project relative file path
		if (!node.id.startsWith(ITEM_JS_PREFIX)) {
			throw new Error("JS file resource " + node.id + " does not start with " + ITEM_JS_PREFIX);
		}
		// a JS resource automatically has a corresponding JS file dependency
		var jsFileNode = getFileNode(ITEM_FILE_PREFIX + node.id.substring(ITEM_JS_PREFIX.length));
		node.data.fileNode = jsFileNode;
		node.data.resIdsRefd = new Set();
		node.data.isReferringJS = true; // is it a file that can contain res refs
		node.addDependency(jsFileNode.id);

		jsNodeIds.add(node.id);
		node.data.onDelete = function onDelete() {
			jsNodeIds.delete(node.id);
		};
		node.data.jsIdsRefd = new Set();
	});

	const getRawJSFileNode = genGetNode("rawjs", (node) => {
		// js item ID is "js:" + project relative file path
		if (!node.id.startsWith(ITEM_JS_PREFIX)) {
			throw new Error("Raw JS file resource " + node.id + " does not start with " + ITEM_RAWJS_PREFIX);
		}
		// a JS resource automatically has a corresponding JS file dependency
		var jsFileNode = getFileNode(ITEM_FILE_PREFIX + node.id.substring(ITEM_RAWJS_PREFIX.length));
		node.data.fileNode = jsFileNode;
		node.addDependency(jsFileNode.id);

		jsNodeIds.add(node.id);
		node.data.onDelete = function onDelete() {
			jsNodeIds.delete(node.id);
		};
		node.data.jsIdsRefd = new Set(); // this one will stay empty actually, but have it for uniformity
	});

	const getToolFileNode = genGetNode("tool", (node) => {
		// js item ID is "tool:" + project relative file path
		if (!node.id.startsWith(ITEM_TOOL_PREFIX)) {
			throw new Error("Tool JS file resource " + node.id + " does not start with " + ITEM_TOOL_PREFIX);
		}
		// a JS resource automatically has a corresponding JS file dependency
		var jsFileNode = getFileNode(ITEM_FILE_PREFIX + node.id.substring(ITEM_TOOL_PREFIX.length));
		node.data.fileNode = jsFileNode;
		node.data.toolCfgDeps = [];
		node.addDependency(jsFileNode.id);
		node.data.buildTests = new Set();
		node.data.buildTestResIds = new Set();

		// note that, although a JS file, tool is not considered a JS node, so it is listed separately
		toolNodeIds.add(node.id);
		node.data.onDelete = function onDelete() {
			toolNodeIds.delete(node.id);
			toolNodesInBuildTest.delete(node.id);
			if (node.data.handledResourceTypes) {
				for (var resType of node.data.handledResourceTypes) {
					delete toolByResType[resType];
				}
			}
		};

		node.data.mustSkipDueToBuildTest = function mustSkipDueToBuildTest(resRef) {
			return node.data.buildTestResRefs.size > 0 && !node.data.buildTestResRefs.has(resRef);
		};
	});

	const getRootFileNode = genGetNode("root", (node) => {
		// js item ID is "root:" + project relative file path
		if (!node.id.startsWith(ITEM_ROOT_PREFIX)) {
			throw new Error("Root file resource " + node.id + " does not start with " + ITEM_ROOT_PREFIX);
		}
		// a JS resource automatically has a corresponding JS file dependency
		var jsFileNode = getFileNode(ITEM_FILE_PREFIX + node.id.substring(ITEM_ROOT_PREFIX.length));
		node.data.fileNode = jsFileNode;
		node.data.resIdsRefd = new Set();
		node.data.isReferringJS = true;
		node.addDependency(jsFileNode.id);
		// group node depends on root node
		var linksNode = getLinksJSNode(LINKSJS_NODE_ID);
		linksNode.addDependency(node.id);

		jsNodeIds.add(node.id);
		node.data.onDelete = function onDelete() {
			jsNodeIds.delete(node.id);
		};
		node.data.jsIdsRefd = new Set();
	});

	const getToolCfgNode = genGetNode("tool-cfg", (node) => {
		if (!node.id.startsWith(ITEM_TOOLCFG_PREFIX)) {
			throw new Error("Tool config entry resource " + node.id + " does not start with " + ITEM_TOOLCFG_PREFIX);
		}
		node.data.configKey = node.id.substring(ITEM_TOOLCFG_PREFIX.length);
	});

	const getResNode = genGetNode("res", (node) => {
		if (!node.id.startsWith(ITEM_RES_PREFIX)) {
			throw new Error("Resource entry resource " + node.id + " does not start with " + ITEM_RES_PREFIX);
		}
		node.data.resIdsRefd = new Set();
		node.data.isReferringJS = false;
		node.data.refHint = null; // for rebuild
		node.data.resType = node.id.substring(ITEM_RES_PREFIX.length).match(REGEXP_RESREF)[1];
		node.data.resGroup = undefined; // intentionally, to provoke movement to group on initial process
		node.data.onDelete = function onDelete() {
			// on delete, also remove self from the resource group
			if (typeof (node.data.resGroup) === 'string') {
				var groupNode = getNodeIfExists(ITEM_RESGRP_PREFIX + node.data.resGroup);
				if (groupNode) {
					groupNode.data.resIds.delete(node.id.substring(ITEM_RES_PREFIX.length));
				}
			}
		};
	});

	const getResGrpNode = genGetNode("res-grp", (node) => {
		if (!node.id.startsWith(ITEM_RESGRP_PREFIX)) {
			throw new Error("Resource group resource " + node.id + " does not start with " + ITEM_RESGRP_PREFIX);
		}
		resGroupNodeIds.add(node.id);
		node.data.resIds = new Set();
		var resGroupId = node.data.resGroupId = node.id.substring(ITEM_RESGRP_PREFIX.length);
		var resGroupFile = resGroupId ? resGroupId.match(REGEXP_GROUP_FILE_BASENAME)[1] + ".es-gen.js" : "";
		Object.defineProperty(node.data, 'fileNode', {
			get() {
				if (resGroupFile) return getFileNode(ITEM_FILE_PREFIX + resGroupFile);
				else return getFileNode(ITEM_FILE_PREFIX + rootCfg["default-resgroup-js"]);
			}
		});
		node.data.fileNode.data.allowNotExist = true;
		// group node depends on all resource groups
		var linksNode = getLinksJSNode(LINKSJS_NODE_ID);
		linksNode.addDependency(node.id);

		node.data.onDelete = function onDelete() {
			resGroupNodeIds.delete(node.id);
		};
	});

	const getLinksJSNode = genGetNode("links-js", (node) => {
		if (!node.id.startsWith(ITEM_LINKSJS_PREFIX)) {
			throw new Error("Links JS resource " + node.id + " does not start with " + ITEM_LINKSJS_PREFIX);
		}
	});

	const getTargetHTMLNode = genGetNode("target-html", (node) => {
		if (!node.id.startsWith(ITEM_TARGETHTML_PREFIX)) {
			throw new Error("Target HTML resource " + node.id + " does not start with " + ITEM_TARGETHTML_PREFIX);
		}
	});

	const getSourceHTMLNode = genGetNode("target-html", (node) => {
		if (!node.id.startsWith(ITEM_SOURCEHTML_PREFIX)) {
			throw new Error("Source HTML resource " + node.id + " does not start with " + ITEM_SOURCEHTML_PREFIX);
		}
	});

	// a resource node(s) can be deliberately skipped for check deps/stale
	// if its relevant tool node is under #build-test
	function isResourceNodeToSkipForBuildTest(nodeId) {
		var node = getNodeIfExists(nodeId);
		if (node && node.data.type == "res") {
			var toolNode = toolByResType[node.data.resType];
			if (!toolNode) return false;

			toolNode = getNodeIfExists(toolNode);
			if (!toolNode) return false;

			return (toolNode.data.buildTests.size > 0 &&
				!toolNode.data.buildTestResIds.has(nodeId.substring(ITEM_RES_PREFIX.length)));
		}

		return false;
	}

	function isResourceTypeToSkipForBuildTest(resType) {
		var toolNode = toolByResType[resType];
		if (!toolNode) return false;

		toolNode = getNodeIfExists(toolNode);
		if (!toolNode) return false;

		return (toolNode.data.buildTests.size > 0);
	}

	async function refreshCachedJS(jsNode) {
		var
			isRawFile = (jsNode.data.type == "rawjs"),
			fileNode = jsNode.data.fileNode,
			projFilePath = fileNode.data.fileProjPath,
			cacheTS = toFuckingInt(jsNode.data.cacheTS),
			fileTS = fileNode.data.cacheTS;
		// fileTS == null -> file does not exist. Still attempt to read though, the reader handles this
		// appropriately and sets errors member
		if (fileTS == null) {
			jsNode.data.cacheTS = 0;
		}

		if (fileTS == null || cacheTS < fileTS || !jsNode.data.parsedFile) {
			// note that we store parsed data in jsNode, but timestamp the file node -
			// it'll signal the rebuild logic
			jsNode.data.parsedFile = await readJSFile({
				path: filework.projectPathToRealPath(projFilePath),
				isRawFile
			});

			if (isRawFile) {
				// raw files are scanned no further
				jsNode.data.charset = "utf-8";
				jsNode.data.iconvCharset = "utf8";
				return;
			} else if (jsNode.data.parsedFile.errors.length <= 0) {
				jsNode.data.charset = jsNode.data.parsedFile.charset;
				jsNode.data.iconvCharset = jsNode.data.parsedFile.iconvCharset;
			}

			fileNode.data.cacheTS = fileTS;
			return true;
		}

		return false;
	}

	async function readLinksFile() {
		try {
			var result = await linksWrappedJSON.read(filework.projectPathToRealPath(rootCfg['links-js']));
			if (!Array.isArray(result)) {
				logInfo("Warning: links JS file data is not a valid array, default to empty array");
				return [];
			}
			return result;
		} catch (e) {
			return [];
		}
	}

	async function writeLinksFile(linksData) {
		linksWrappedJSON.write(filework.projectPathToRealPath(rootCfg['links-js']), linksData);
	}

	function ensureToolProcess() {
		if (spTool == null) {
			spTool = openClient(__dirname + "/toolsp.js");
			spTool.logErrorWithSource = logErrorWithSource;
			spTool.logInfoWithSource = logInfoWithSource;
			spTool.logDebugWithSource = logDebugWithSource;
			spTool.performOnStartup = async function initToolProcess() {
				var toolFilesByResType = new Object(),
					resTypesToSkipForBuildTest = new Set();
				for (var resType in toolByResType) {
					toolFilesByResType[resType] = {
						toolPath: njsPath.resolve(getNode(toolByResType[resType]).data.fileNode.data.filePath)
					};
					if (isResourceTypeToSkipForBuildTest(resType)) {
						resTypesToSkipForBuildTest.add(resType);
					}
				}
				await spTool.client.initialize(rootFilePath,
					rootCfg['default-resgroup-js'],
					toolFilesByResType,
					rootCfg,
					toolsCurrentCfg,
					resTypesToSkipForBuildTest);
			};
		}
	}

	function getNode(nodeId) {
		var [prefix, mainId] = parseNodeId(nodeId);
		switch (prefix) {
		case ITEM_JS_PREFIX: return getJSFileNode(nodeId);
		case ITEM_RAWJS_PREFIX: return getRawJSFileNode(nodeId);
		case ITEM_ROOT_PREFIX: return getRootFileNode(nodeId);
		case ITEM_TOOL_PREFIX: return getToolFileNode(nodeId);
		case ITEM_FILE_PREFIX: return getFileNode(nodeId);
		case ITEM_TOOLCFG_PREFIX: return getToolCfgNode(nodeId);
		case ITEM_RES_PREFIX: return getResNode(nodeId);
		case ITEM_RESGRP_PREFIX: return getResGrpNode(nodeId);
		case ITEM_LINKSJS_PREFIX: return getLinksJSNode(nodeId);
		case ITEM_SOURCEHTML_PREFIX: return getSourceHTMLNode(nodeId);
		case ITEM_TARGETHTML_PREFIX: return getTargetHTMLNode(nodeId);
		}
		throw new Error("Bad node type prefix " + prefix);
	}

	function deleteNode(nodeId) {
		var node = getNodeIfExists(nodeId);
		if (!node) return; // already deleted/not exists
		if (node.data.onDelete) node.data.onDelete();
		nodeIdsDeletedThisRespin.add(nodeId);
		if (extraNodesToCheckOnNextPerform.delete(node)) {
			logInfo("Incomplete item %s deleted, its related errors will be disregarded", node.id);
		}
		itemsInError.delete(nodeId);
		var nodeIds = node.getDependentIds(); // we'll also cascadedly delete orphaned nodes
		depGraph.deleteNode(nodeId);
		for (var subNodeId of nodeIds) {
			if (depGraph.getNode(subNodeId).isOrphaned) {
				deleteNode(subNodeId);
			}
		}
	}

	function markFailed(node, e) {
		node.data.state = "failed";
		node.data.rebuildCause = "Retry previously failed item";
		extraNodesToCheckOnNextPerform.add(node);
		var nodeErrors = itemsInError.get(node.id);
		if (!nodeErrors) {
			nodeErrors = new Array();
			nodeErrors.dependencyErrors = new Set();
			itemsInError.set(node.id, nodeErrors);
		}
		if (e instanceof Error && Array.isArray(e.dependenciesInError)) {
			for (var dep of e.dependenciesInError) {
				nodeErrors.dependencyErrors.add(dep);
			}
		} else {
			nodeErrors.push(e);
		}
		logError("Item %s incomplete", node.id);
	}

	async function getDeps(task, { nodeId }) {
		var [prefix, mainId] = parseNodeId(nodeId);
		switch (prefix) {
		case ITEM_JS_PREFIX:
		case ITEM_RAWJS_PREFIX:
		case ITEM_ROOT_PREFIX:
		case ITEM_TOOL_PREFIX:
			var jsNode = getNode(nodeId),
				isRawFile = (prefix == ITEM_RAWJS_PREFIX),
				isToolFile = (prefix == ITEM_TOOL_PREFIX),
				isRootFile = (prefix == ITEM_ROOT_PREFIX),
				localFilework = filework.pathGetterRelToProjFilePath(mainId); // mainId is project file path in these cases
			var refreshed = await refreshCachedJS(jsNode);
			var parsedFile = jsNode.data.parsedFile;
			if (parsedFile.errors.length > 0) {
				for (var error of parsedFile.errors) {
					logError("Error in %s: %s", jsNode.data.fileNode.data.fileProjPath, error);
				}
				throw new Error(parsedFile.errors.length + " error(s) found while scanning the JS file");
			}

			// JS dependencies always include its main file
			var deps = new Set([ITEM_FILE_PREFIX + mainId]),
				toolCfgDeps = new Array();
			for (var command of parsedFile.commands) {
				// generic JS commands
				CMD:
				switch (command.cmd) {
				case "use":
				case "use-raw":
					var fileName = command.args[0];
					if (!fileName) {
						parsedFile.errors.push("line " + command.line + ": #use/#use-raw: expected a JS file name");
						break CMD;
					}
					if (fileName.match(/[*?]/)) {
						parsedFile.errors.push("line " + command.line + ": wildcards not supported for JS files");
						break CMD;
					}
					var actualFileName = localFilework.fileNameToProjPath(fileName);
					if (isToolFile) {
						parsedFile.errors.push("line " + command.line + ": #use directive is disallowed in a tool file");
						break CMD;
					}

					if (actualFileName == rootProjPath) {
						parsedFile.errors.push("line " + command.line + ": can not #use/#use-raw the project root file");
						break CMD;
					}

					if (command.cmd == "use") {
						deps.add(ITEM_JS_PREFIX + actualFileName);
					} else {
						deps.add(ITEM_RAWJS_PREFIX + actualFileName);
					}
					break;

				case "use-cfg":
					if (!isToolFile) {
						parsedFile.errors.push("line " + command.line + ": #use-cfg directive is only allowed in a tool file");
						break CMD;
					}
					var cfgKeyName = command.args[0];
					if (!cfgKeyName) {
						parsedFile.errors.push("line " + command.line + ": #use-cfg: expected a string for a config key name");
						break CMD;
					}
					deps.add(ITEM_TOOLCFG_PREFIX + cfgKeyName);
					toolCfgDeps.push(ITEM_TOOLCFG_PREFIX + cfgKeyName);
					break;
				}
			}

			if (isToolFile) {
				jsNode.data.toolCfgDeps = toolCfgDeps;
				// tools additionally depend on the root
				deps.add(ITEM_ROOT_PREFIX + rootProjPath);
			}
			return deps;

		case ITEM_TOOLCFG_PREFIX:
			// cfg entry depends on project root file
			return new Set([ITEM_ROOT_PREFIX + rootProjPath]);

		case ITEM_RES_PREFIX:
			try {
				var resNode = getNode(nodeId), resType = resNode.data.resType;
				if (!toolByResType[resType]) {
					logError("Error in %s: no valid tool found for resource type '%s'", resNode.id, resType);
					throw new Error("No valid tool found for resource type '" + resType + "'");
				}
				ensureToolProcess();
				return new Set([...await spTool.client.getBuildDependencies(resType, mainId), toolByResType[resType]]);
			} catch (e) {
				throw e;
			}

		case ITEM_RESGRP_PREFIX:
			var resGrpNode = getNode(nodeId), result = new Set();
			result.add(resGrpNode.data.fileNode.id); // res group's file
			// res ids
			for (var resId of resGrpNode.data.resIds) {
				result.add(ITEM_RES_PREFIX + resId);
			}
			return result;

		case ITEM_LINKSJS_PREFIX:
			// links JS depends on the root JS (and, by transition, from all other JSes) and from the res group nodes
			var result = new Set([ITEM_ROOT_PREFIX + rootProjPath]),
				badNodeIds = new Array();
			for (var resGroupNodeId of resGroupNodeIds) {
				if (nodeExists(resGroupNodeId)) {
					result.add(resGroupNodeId);
					requestCheckNode({ nodeId: resGroupNodeId }).setDependsOn(task.task);
				} else {
					badNodeIds.push(resGroupNodeId);
				}
			}

			await task.untilResumed();
			// delete the group nodes we've found to be missing
			for (var badNodeId of badNodeIds) {
				resGroupNodeIds.delete(badNodeId);
			}
			return result;

		case ITEM_SOURCEHTML_PREFIX:
			// source depends on root (to access the up-to-date rootcfg for the source filename)
			return new Set([ITEM_ROOT_PREFIX + rootProjPath]);

		case ITEM_TARGETHTML_PREFIX:
			// target depends on source, plus on root (for same reason as the source)
			return new Set([SOURCEHTML_NODE_ID, ITEM_ROOT_PREFIX + rootProjPath]);
		}

		// any other node types not enumerated here have no dependencies
		return new Set();
	}

	function getLinksArray(forRelease) {
		var resultSet = new Set();

		// add res groups first
		for (var resGroupNodeId of resGroupNodeIds) {
			resultSet.add(depGraph.getNode(resGroupNodeId));
		}

		// add the JS files, in the reverse dependency order, starting from (that is, ending with) root
		function addJS(jsNodeId) {
			var node = depGraph.getNode(jsNodeId);
			if (resultSet.has(node) || !node.data.fileNode) {
				return; // already counted, or it is a raw file node to skip
			}
			for (var depJSNodeId of node.getDependencyIds()) {
				addJS(depJSNodeId);
			}
			resultSet.add(node);
		}

		addJS(ITEM_ROOT_PREFIX + rootProjPath);

		// construct the data array
		var result = new Array();
		for (var node of resultSet) {
			result.push({
				file: node.data.fileNode.data.fileProjPath.substring(1), // strip leading '/'
				charset: node.data.charset || 'utf-8',
				iconvCharset: forRelease ? (node.data.iconvCharset || 'utf8') : undefined
			});
		}
		return result;
	}

	async function getSourceHTMLParsed() {
		var sourceRealPath = filework.projectPathToRealPath(rootCfg["source"]),
			text = iconvlite.decode(await njsFs.promises.readFile(sourceRealPath), "ascii"); // using "as is" 8-bit encoding
		text = text.split(REGEXP_SOURCE_TAG);
		if (text.length < 2) {
			throw new Exception("Source template " + rootCfg["source"] + " contains no <!--#emery-target--> tag");
		} else if (text.length > 2) {
			throw new Exception("Source template " + rootCfg["source"] + " contains more than one <!--#emery-target--> tags");
		}

		return { prologue: text[0], epilogue: text[1] };
	}

	async function isUpToDate(task, { nodeId, depsChanged }) {
		var [prefix, mainId] = parseNodeId(nodeId),
			node = getNode(nodeId);
		switch (prefix) {
		case ITEM_FILE_PREFIX:
			var projFilePath = mainId,
				fileTS = await filework.fileTimestamp(projFilePath);
			if (fileTS === null) {
				if (node.data.allowNotExist) return true;
				throw new Error("File " + projFilePath + " does not exist");
			}
			return (toFuckingInt(node.data.cacheTS) >= fileTS);

		case ITEM_TOOL_PREFIX:
			// for toolfile, check against cfg type deps
			if (prefix == ITEM_TOOL_PREFIX) {
				for (var toolCfgNodeId of node.data.toolCfgDeps) {
					var toolCfgNode = getNode(toolCfgNodeId);
					if (toFuckingInt(node.data.cacheTS) < toolCfgNode.data.cacheTS) return false; // stale against a tool cfg
				}
			}
			// and then fallthrough to common logic with JS files

		case ITEM_JS_PREFIX:
		case ITEM_RAWJS_PREFIX:
		case ITEM_ROOT_PREFIX:
			if (depsChanged) return false; // dependencies changed
			var fileNode = getNode(ITEM_FILE_PREFIX + mainId);
			if (toFuckingInt(node.data.cacheTS) < fileNode.data.cacheTS) return false; // stale against its file
			break;

		case ITEM_TOOLCFG_PREFIX:
			return !!node.data.cacheTS;

		case ITEM_RES_PREFIX:
			if (isResourceNodeToSkipForBuildTest(node.id)) {
				resNodesToRecheckAfterBuildTest.add(node.id);
				return true;
			}

			ensureToolProcess();
			var resRefMatch = mainId.match(REGEXP_RESREF),
				resType = resRefMatch[1];
			var checkResult = await spTool.client.isResourceUpToDate(resType, mainId, node.data.refHint);
			if (checkResult.wereSkips) {
				resNodesToRecheckAfterBuildTest.add(node.id);
			}
			// regardless on check result, we rescan the resource for possible dependent res refs
			node.data.resIdsRefd.clear();
			for (var resRef of checkResult.resRefs) {
				var subResRefMatch = resRef.match(REGEXP_RESREF),
					subResType = subResRefMatch[1];

				var { resId } = await spTool.client.parseResourceRef(subResType, { data: resRef });
				node.data.resIdsRefd.add(resId);
				requestScanResRef(task, { resRef, entry: { data: resRef }});
			}
			return checkResult.isUpToDate && !node.data.forceRebuild; // forceRebuild can be set by #build-test

		case ITEM_RESGRP_PREFIX:
			if (depsChanged) return false;
			if (toFuckingInt(node.data.cacheTS) < node.data.fileNode.data.cacheTS) return false; // stale against file
			for (var resId of node.data.resIds) {
				var resNode = getNode(ITEM_RES_PREFIX + resId);
				if (toFuckingInt(node.data.cacheTS) < resNode.data.cacheTS) return false; // stale against a resource from the group
			}
			return true;

		case ITEM_LINKSJS_PREFIX:
			if (depsChanged) return false;
			
			// links is not up to date if the currently saved links differ from actual links
			var actualLinks = getLinksArray(),
				curLinks = await readLinksFile();
			return jsonEquals(actualLinks, curLinks);

		case ITEM_SOURCEHTML_PREFIX:
			var fileTS = await filework.fileTimestamp(rootCfg["source"]);
			return (toFuckingInt(node.data.cacheTS) > fileTS);

		case ITEM_TARGETHTML_PREFIX:
			var fileTS = await filework.fileTimestamp(rootCfg["target"]),
				sourceTS = await filework.fileTimestamp(rootCfg["source"]);
			node.data.cacheTS = fileTS;
			return (fileTS > sourceTS);
		}
		// in any other case, consider the item up to date
		return true;
	}

	function resetProjTargetNodesIfNeeded() {
		if (needResetProjTargetNodes) {
			needResetProjTargetNodes = false;
			var linksNode = getNode(LINKSJS_NODE_ID),
				sourceHtmlNode = getNode(SOURCEHTML_NODE_ID),
				targetHtmlNode = getNode(TARGETHTML_NODE_ID),
				defResGroupNode = getNode(ITEM_RESGRP_PREFIX);
		}
	}

	var checkpointTasks = null;

	function getCheckpointTasks() {
		if (!checkpointTasks) {
			checkpointTasks = {
				afterFileUpdatesTask: depTaskDoer.postTask(...taskAfterFileUpdates()),
				afterJSTask: depTaskDoer.postTask(...taskAfterJS()),
				afterToolsCfgTask: depTaskDoer.postTask(...taskAfterToolsCfg()),
				afterToolsTask: depTaskDoer.postTask(...taskAfterTools()),
				collectUnreachableScriptsTask: depTaskDoer.postTask(...taskCollectUnreachableScripts()),
				afterResourcesTask: depTaskDoer.postTask(...taskAfterResources()),
				afterResGroupsTask: depTaskDoer.postTask(...taskAfterResGroups()), // only 1st of them
				flushModifiedGroupsTask: depTaskDoer.postTask(...taskFlushModifiedGroups()) // only 1st of them
			};
			checkpointTasks.afterJSTask.setDependsOn(checkpointTasks.afterFileUpdatesTask);
			checkpointTasks.afterToolsCfgTask.setDependsOn(checkpointTasks.afterJSTask);
			checkpointTasks.afterToolsTask.setDependsOn(checkpointTasks.afterToolsCfgTask);
			checkpointTasks.collectUnreachableScriptsTask.setDependsOn(checkpointTasks.afterToolsTask);
			checkpointTasks.afterResourcesTask.setDependsOn(checkpointTasks.collectUnreachableScriptsTask);
			checkpointTasks.afterResGroupsTask.setDependsOn(checkpointTasks.afterResourcesTask);
			checkpointTasks.flushModifiedGroupsTask.setDependsOn(checkpointTasks.afterResGroupsTask);

			for (var checkpointTask of Object.values(checkpointTasks)) {
				setNonFinalTask(checkpointTask);
			}
		}
		return checkpointTasks;
	}

	function requestCheckNode({ nodeId, force = false, isFileUpdate = false }) {
		var checkTask = nodeCheckTasks[nodeId];
		if (checkTask) {
			return checkTask;
		}

		var [prefix, mainId] = parseNodeId(nodeId),
			node = getNode(nodeId);

		if (force && (!node.data.state || node.data.state == "stable")) {
			node.data.state = force || "need-check";
		}

		// checkNode task consists of 2 steps - checking node deps and checking node stale.
		// After deps checking for all nodes, we need to perform graph validation task (which, as a heavy
		// task, should be preformed once as few times as possible), and only then we can proceed to stale checking.
		// Hence we need to have 2 sub-tasks, checkNodeDeps and checkNodeStale, which have to run in sequence
		// coordinated by main checkNode, and will have to pass some information to each other.
		checkTask = (nodeCheckTasks[nodeId]) = depTaskDoer.postTask(...taskCheckNode({ nodeId }));
		checkTask.data = {
			checkNodeDepsStart: depTaskDoer.postUnblockerTask("check-node-start " + nodeId),
			checkNodeDepsTask: depTaskDoer.postTask(...taskCheckNodeDeps({ nodeId })),
			checkNodeStaleTask: depTaskDoer.postTask(...taskCheckNodeStale({ nodeId })),
			validateDepGraphTask: null, // also work as indicator of changed dependencies (if they are not, we don't query the validation)
			requireSuccessfulDependencies: false // if true, check-stale will require success of checkNode of all its deps
		};
		checkTask.data.checkNodeDepsTask.data = { checkTask };
		checkTask.data.checkNodeStaleTask.data = { checkTask };
		checkTask.data.checkNodeStaleTask.setDependsOn(checkTask.data.checkNodeDepsTask);
		checkTask.data.checkNodeDepsTask.setDependsOn(checkTask.data.checkNodeDepsStart);
		// check task is non-final in advance
		var finalizeTask = depTaskDoer.postTask(...taskFinalizeSpin());
		finalizeTask.setDependsOn(checkTask);

		var {
			afterFileUpdatesTask,
			afterJSTask,
			afterToolsCfgTask,
			afterToolsTask,
			collectUnreachableScriptsTask,
			afterResourcesTask,
			afterResGroupsTask,
			flushModifiedGroupsTask
		} = getCheckpointTasks();

		// check for a certain node type must be ordered against appropriate checkpoint tasks
		switch (prefix) {
		case ITEM_TOOLCFG_PREFIX:
			checkTask.setDependsOn(afterJSTask);
			afterToolsCfgTask.setDependsOn(checkTask);
			break;

		case ITEM_FILE_PREFIX:
			if (isFileUpdate) {
				afterFileUpdatesTask.setDependsOn(checkTask);
			} else {
				afterJSTask.setDependsOn(checkTask);
			}
			break;

		case ITEM_JS_PREFIX:
		case ITEM_RAWJS_PREFIX:
		case ITEM_ROOT_PREFIX:
			afterJSTask.setDependsOn(checkTask);
			break;

		case ITEM_TOOL_PREFIX:
			checkTask.setDependsOn(afterToolsCfgTask);
			afterToolsTask.setDependsOn(checkTask);
			break;

		case ITEM_RES_PREFIX:
			checkTask.setDependsOn(collectUnreachableScriptsTask);
			afterResourcesTask.setDependsOn(checkTask);
			checkTask.data.requireSuccessfulDependencies = true;
			break;

		case ITEM_RESGRP_PREFIX:
			checkTask.setDependsOn(afterResourcesTask);
			afterResGroupsTask.setDependsOn(checkTask);
			checkTask.data.requireSuccessfulDependencies = true;
			break;

		case ITEM_LINKSJS_PREFIX:
			checkTask.setDependsOn(flushModifiedGroupsTask);
			checkTask.data.requireSuccessfulDependencies = true;
			break;

		// the rest (source/target HTML) are effectively independent,
		// but requireSuccessfulDependencies should be true for them
		default:
			checkTask.data.requireSuccessfulDependencies = true;
			break;
		}

		return checkTask;
	}

	function requestScanResRef(task, { resRef, entry, force }) {
		var scanTask = task.postDependentTask(...taskScanResRef({ resRef, entry, force }));
		// scan task is non-final in advance
		var finalizeTask = depTaskDoer.postTask(...taskFinalizeSpin());
		finalizeTask.setDependsOn(scanTask);

		var {
			afterJSTask,
			afterToolsCfgTask,
			afterToolsTask,
			afterResourcesTask,
			afterResGroupsTask,
			flushModifiedGroupsTask,
			collectUnreachableScriptsTask
		} = getCheckpointTasks();

		scanTask.setDependsOn(afterToolsTask);
		afterResourcesTask.setDependsOn(scanTask);

		return scanTask;
	}

	async function rebuildJS(task, { nodeId, depsChanged }) {
		// note it is a subroutine for task, not an independent task
		var [prefix, mainId] = parseNodeId(nodeId),
			jsNode = getNode(nodeId),
			isRootFile = prefix == ITEM_ROOT_PREFIX,
			isToolFile = prefix == ITEM_TOOL_PREFIX,
			isRawFile = prefix == ITEM_RAWJS_PREFIX,
			isActuallyRebuilt = depsChanged ||
				(toFuckingInt(jsNode.data.cacheTS) < toFuckingInt(jsNode.data.fileNode.data.cacheTS)), // JS file changed
			oldTools = jsNode.data.toolsDeclared,
			handledResourceTypes = jsNode.data.handledResourceTypes || new Set(),
			newHandledResourceTypes = new Set(),
			buildTests = new Set(),
			newTools;
		await refreshCachedJS(jsNode);
		var parsedFile = jsNode.data.parsedFile,
			toolsNewCfg = new Object(),
			debugOn = false;
		if (isToolFile) {
			jsNode.data.buildTestResIds.clear();
		}

		for (var command of parsedFile.commands) {
			CMD:
			switch (command.cmd) {
			case "use":
			case "use-raw":
			case "use-cfg":
			case "charset":
				break CMD; // these are already handled on check/getDeps

			case "tool":
				if (!isRootFile) {
					parsedFile.errors.push("line " + command.line + ": #tool directive is only allowed in project root file");
					break CMD;
				}

				// set tool node to check
				var fileName = command.args[0];
				if (!fileName || command.args.length != 1) {
					parsedFile.errors.push("line " + command.line + ": #tool: expected an exactly one tool JS file name");
					break CMD;
				}
				if (fileName.match(/[*?]/)) {
					parsedFile.errors.push("line " + command.line + ": wildcards not supported for tool JS files");
					break CMD;
				}
				var localFilework = filework.pathGetterRelToProjFilePath(mainId), // mainId is project file path in this case
					actualFileName = localFilework.fileNameToProjPath(fileName),
					toolNode = getToolFileNode(ITEM_TOOL_PREFIX + actualFileName);
				requestCheckNode({ nodeId: toolNode.id, force: "need-check" }).setDependsOn(task.task);
				newTools = (newTools || new Array());
				newTools.push(command);
				break CMD;

			case "html":
				if (!isRootFile) {
					parsedFile.errors.push("line " + command.line + ": #html directive is only allowed in project root file");
					break CMD;
				}
				if (!command.args.source || typeof(command.args.source) !== 'string') {
					parsedFile.errors.push("line " + command.line + ": #html: source parameter is required");
					break CMD;
				}
				if (command.args.target && typeof(command.args.target) !== 'string') {
					parsedFile.errors.push("line " + command.line + ": #html: target parameter must be a string");
					break CMD;
				}
				if (command.args['release-target'] && typeof(command.args['release-target']) !== 'string') {
					parsedFile.errors.push("line " + command.line + ": #html: release-target parameter must be a string");
					break CMD;
				}
				if (command.args['links-js'] && typeof(command.args['links-js']) !== 'string') {
					parsedFile.errors.push("line " + command.line + ": #html: links-js parameter must be a string");
					break CMD;
				}
				if (command.args['default-resgroup-js'] && typeof(command.args['default-resgroup-js']) !== 'string') {
					parsedFile.errors.push("line " + command.line + ": #html: default-resgroup-js parameter must be a string");
					break CMD;
				}
				var oldRootCfg = rootCfg;
				rootCfg = {
					"source": command.args.source, // proj file path of the source template (typically .src.html)
					"target": command.args.target || rootProjPathNoExt + ".dbg.html", // proj file path of the target html (.dbg.html)
					"release-target": command.args['release-target'] || rootProjPathNoExt + ".html", // proj file path of the target amalgamated release html (.html)
					"links-js": command.args['links-js'] || rootProjPathNoExt + "-links-noed.es-gen.js", // proj file path of the generated ESpin links JS (links to the affected JS files to load, in the order)
					"default-resgroup-js": command.args['default-resgroup-js'] || rootProjPathNoExt + "-defres.es-gen.js" // proj file path of the generated default resource group file
				};
				if (!jsonEquals(oldRootCfg, rootCfg)) {
					needResetProjTargetNodes = true;
				}
				break CMD;

			case "builds-res":
				if (!isToolFile) {
					parsedFile.errors.push("line " + command.line + ": #builds-res directive is only allowed in tool JS files");
					break CMD;
				}
				if (!Array.isArray(command.args)) {
					parsedFile.errors.push("line " + command.line + ": #builds-res should specify one or more resource ID prefixes");
					break CMD;
				}
				for (var resType of command.args) {
					if (typeof(resType) != 'string') {
						parsedFile.errors.push("line " + command.line + ": #builds-res: expected a string for a resource ID prefix");
						break CMD;
					}
					newHandledResourceTypes.add(resType);
				}
				break;

			case "tool-cfg":
				if (!isRootFile) {
					parsedFile.errors.push("line " + command.line + ": #tool-cfg directive is only allowed in project root file");
					break CMD;
				}
				if (typeof (command.args) != 'object' || Array.isArray(command.args)) {
					parsedFile.errors.push("line " + command.line + ": expected one or more key-values in #tool-cfg directive");
					break CMD;
				}
				for (var cfgKey in command.args) {
					getNode(ITEM_TOOLCFG_PREFIX + cfgKey);
					toolsNewCfg[cfgKey] = command.args[cfgKey];
				}
				break;

			case "build-test":
				if (!Array.isArray(command.args)) {
					parsedFile.errors.push("line " + command.line + ": expected one or more resource ref strings in #build-test directive");
					break CMD;
				}

				for (var resRef of command.args) {
					if (typeof (resRef) != 'string') {
						parsedFile.errors.push("line " + command.line + ": resource ref strings only are allowed in #build-test directive");
						break CMD;
					}

					var resRefMatch = resRef.match(REGEXP_RESREF);
					if (!resRefMatch) {
						parsedFile.errors.push("line " + command.line + ": incorrect resource ref string '" + resRef + "' in #build-test directive");
						break CMD;
					}
			
					buildTests.add({ data: resRef, line: command.line, force: true });
				}
				break;

			case "debug":
				if (!(isToolFile || isRootFile)) {
					parsedFile.errors.push("line " + command.line + ": #debug directive is only allowed in tool JS files or project root file");
					break CMD;
				}
				debugOn = true;
				break;

			default:
				parsedFile.errors.push("line " + command.line + ": unsupported directive #" + command.cmd);
				break CMD;
			}
		}

		if (isToolFile) {
			if (!setEquals(handledResourceTypes, newHandledResourceTypes)) {
				// check if we got no ambiguity in res type handlers
				for (var resType of newHandledResourceTypes) {
					if (toolByResType[resType] && toolByResType[resType] != nodeId) {
						parsedFile.errors.push("resource type '" + resType + "' is already built by " + toolByResType[resType]);
					}
				}
				
				isActuallyRebuilt = true;
			}

			// validate #build-test's inside the tool: such ones can only be for the tool's own buildable res types
			var badBuildTests = new Array();
			for (var buildTest of buildTests) {
				var resRefMatch = buildTest.data.match(REGEXP_RESREF),
					resType = resRefMatch[1];
				if (!newHandledResourceTypes.has(resType)) {
					parsedFile.errors.push("line " + buildTest.line + ": #build-test inside tool file is only allowed for its own res types (" +
						[...newHandledResourceTypes] + ")");
					badBuildTests.push(buildTest);
				}
			}

			for (var badBuildTest of badBuildTests) {
				buildTests.delete(badBuildTest);
			}
		}

		if (!isToolFile && !isRawFile) {
			jsNode.data.resIdsRefd.clear();
			for (var resRef of [...buildTests, ...parsedFile.resRefs]) {
				resRef.file = jsNode.data.fileNode.data.filePath; // or fileProjPath
				jsNode.data.resIdsRefd.add(resRef.data); // will be replaced later at resolveJSResIdsRefd
				var checkResRefTask = requestScanResRef(task, {
					resRef: resRef.data, entry: resRef, force: !!resRef.force
				});
				var resolveJSResIdsRefdTask = depTaskDoer.postTask(...taskResolveJSResIdsRefd({ jsNode }));
				resolveJSResIdsRefdTask.setDependsOn(checkResRefTask);
				var { collectUnreachableScriptsTask } = getCheckpointTasks();
				collectUnreachableScriptsTask.setDependsOn(resolveJSResIdsRefdTask);
			}
		}

		if (isToolFile && isActuallyRebuilt) {
			for (var resType of (jsNode.data.handledResourceTypes || [])) {
				delete toolByResType[resType];
			}
			for (var resType of newHandledResourceTypes) {
				toolByResType[resType] = nodeId;
			}
			jsNode.data.handledResourceTypes = newHandledResourceTypes;
		}

		if (isToolFile) {
			for (var resType of jsNode.data.handledResourceTypes) {
				debugOns[resType] = debugOn;
			}

			// and also do updates related to build-tests
			jsNode.data.buildTests = buildTests;
			jsNode.data.buildTestResIds = new Set();

			if (buildTests.size > 0) {
				toolNodesInBuildTest.add(jsNode.id);
			} else {
				toolNodesInBuildTest.delete(jsNode.id);
			}

			if (buildTests.size <= 0) {
				// invalidate resource types (new) built by this tool
				// unless it is a tool file, and it contains #build-test's
				var badNodeIds = new Array();
				for (var resGroupNodeId of resGroupNodeIds) {
					var resGroupNode = getNodeIfExists(resGroupNodeId);
					if (resGroupNode) {
						for (var resId of resGroupNode.data.resIds) {
							var resNode = getNodeIfExists(ITEM_RES_PREFIX + resId);
							if (resNode && newHandledResourceTypes.has(resNode.data.resType)) {
								resNode.data.forceRebuild = true;
								requestCheckNode({ nodeId: resNode.id, force: "need-check" }).setDependsOn(task.task);
							}
						}
					} else {
						badNodeIds.push(resGroupNodeId);
					}
				}

				// invalid resource ID nodes we've found are to be deleted
				for (var badNodeId of badNodeIds) {
					deleteNode(badNodeId);
				}
			} else {
				// if #build-test was encountered in a tool file (assuming it is one of its types),
				// we assume the tool debugging is under way, and instead of propagating the checks to all
				// of the affected resources we only do it on the ones encountered in its #build-test's
				for (var resRef of buildTests) {
					resRef.file = jsNode.data.fileNode.data.filePath; // or fileProjPath
					var checkResRefTask = requestScanResRef(task, {
						resRef: resRef.data, entry: resRef, force: true
					});
					// for tool file, resolveJSResIdsRefdTask works different way, by adding decoded res ids
					// to jsNode.data.buildTestResIds
					var resolveJSResIdsRefdTask = depTaskDoer.postTask(...taskResolveJSResIdsRefd({ jsNode }));
					resolveJSResIdsRefdTask.setDependsOn(checkResRefTask);
					var { collectUnreachableScriptsTask } = getCheckpointTasks();
					collectUnreachableScriptsTask.setDependsOn(resolveJSResIdsRefdTask);
				}
			}
		}

		if (isRootFile) {
			debugOns[""] = debugOn;

			// update declared tools set
			jsNode.data.toolsDeclared = newTools;
			isActuallyRebuilt |= !(jsonEquals(oldTools, newTools));

			if (!jsonEquals(toolsCurrentCfg, toolsNewCfg)) {
				// invalidate the affected cfg nodes
				for (var cfgKey in toolsNewCfg) {
					if (!jsonEquals(toolsNewCfg[cfgKey], toolsCurrentCfg[cfgKey])) {
						var cfgNodeId = ITEM_TOOLCFG_PREFIX + cfgKey,
							cfgNode = getNode(cfgNodeId);
						cfgNode.data.cacheTS = null;
						requestCheckNode({ nodeId: cfgNodeId, force: "need-check" }).setDependsOn(task.task);
					}
				}
				toolsCurrentCfg = toolsNewCfg;
			}

			// project target nodes
			resetProjTargetNodesIfNeeded();
		}

		// check errors (in the end)
		if (parsedFile.errors.length > 0) {
			for (var error of parsedFile.errors) {
				logError("Error in %s: %s", jsNode.data.fileNode.data.fileProjPath, error);                                                 	
			}
			throw new Error(parsedFile.errors.length + " error(s) found while scanning the JS file (rebuild stage)");
		}

		return isActuallyRebuilt;
	}

	async function scanResRef(task, { resRef, entry, force }) {
		nonFinalTask(task);
		task.requireSuccessfulDependencies();
		var resRefMatch = resRef.match(REGEXP_RESREF),
			resType = resRefMatch[1],
			toolForResType = toolByResType[resType];
		if (!toolForResType) {
			logError("Error in %s: line %s: no valid tool found for resource type '%s'", entry.file, entry.line, resType);
			throw new Error("Error while scanning resource ref " + resRef);
		}

		try {
			ensureToolProcess();
			var parsedResRef = await spTool.client.parseResourceRef(resType, entry);
			var resNode = getNode(ITEM_RES_PREFIX + parsedResRef.resId);
			if (parsedResRef.hint) {
				resNode.data.refHint = parsedResRef.hint;
			}

			resNode.data.forceRebuild = force;
			requestCheckNode({ nodeId: resNode.id, force: "need-check" });

			// resource moved to a different group than it was in - the groups will need re-checked
			if (parsedResRef.group != resNode.data.resGroup) {
				if (typeof (resNode.data.resGroup) !== 'undefined') {
					getNode(ITEM_RESGRP_PREFIX + resNode.data.resGroup).data.resIds.delete(parsedResRef.resId);
					// check the source group
					requestCheckNode({ nodeId: ITEM_RESGRP_PREFIX + resNode.data.resGroup, force: "need-check" }).setDependsOn(task.task);
				}
				getNode(ITEM_RESGRP_PREFIX + parsedResRef.group).data.resIds.add(parsedResRef.resId);
				resNode.data.resGroup = parsedResRef.group;
				// check the destination group
				requestCheckNode({ nodeId: ITEM_RESGRP_PREFIX + parsedResRef.group, force: "need-check" });
			}
		} catch (e) {
			logError("Error in %s: line %s: %s", entry.file, entry.line, e);
			markFailed(node, e);
			throw e;
		}
	}
	function taskScanResRef(args) { return ["scan-res-ref " + args.resRef, scanResRef, args]; }

	async function resolveJSResIdsRefd(task, { jsNode }) {
		nonFinalTask(task);
		try {
			ensureToolProcess();

			if (jsNode.data.type != "tool") {
				// for non-tool, we resolve the referenced res ids
				var actualResIds = new Set();
				for (var resRef of jsNode.data.resIdsRefd) {
					var subResRefMatch = resRef.match(REGEXP_RESREF),
						subResType = subResRefMatch[1];

					var { resId } = await spTool.client.parseResourceRef(subResType, { data: resRef });
					actualResIds.add(resId);
				}
				jsNode.data.resIdsRefd = actualResIds;
			} else {
				// for a tool, we resolve the build test res refs
				var actualResIds = new Set();
				for (var buildTest of jsNode.data.buildTests) {
					var subResRefMatch = buildTest.data.match(REGEXP_RESREF),
						subResType = subResRefMatch[1];
					
					var { resId } = await spTool.client.parseResourceRef(subResType, buildTest);
					actualResIds.add(resId);
				}
				jsNode.data.buildTestResIds = actualResIds;

				// push resource checks, as it has been skipped for the tool by the generic rebuild
				for (var resId of actualResIds) {
					requestCheckNode({ nodeId: ITEM_RES_PREFIX + resId, force: "need-check" });
				}
			}
		} catch (e) {
			logError("Error in %s: %s", task.taskId, e);
			markFailed(node, e);
			throw e;
		}
	}
	function taskResolveJSResIdsRefd(args) { return ["resolve-js-res-refs " + args.jsNode.id, resolveJSResIdsRefd, args]; }

	// return true if actual rebuild happened, false if the node remains effectively unchanged
	async function rebuild(task, { nodeId, depsChanged }) {
		// note it is a subroutine for task, not an independent task
		var [prefix, mainId] = parseNodeId(nodeId),	result = false;
		switch (prefix) {
		case ITEM_ROOT_PREFIX:
		case ITEM_JS_PREFIX:
		case ITEM_RAWJS_PREFIX:
		case ITEM_TOOL_PREFIX:
			result = await rebuildJS(task, { nodeId, depsChanged });
			break;

		case ITEM_TOOLCFG_PREFIX:
			// rebuilding toolcfg is just updating the timestamp (the cfg itself was updated with root node rebuild)
			var node = getNode(nodeId);
			result = !node.data.cacheTS;
			if (result) {
				node.data.cacheTS = new Date().getTime();
			}
			break;

		case ITEM_RES_PREFIX:
			var resNode = getNode(nodeId),
				hint = resNode.data.refHint,
				{ modified, resRefs } = await spTool.client.rebuildResource(resNode.data.resType, mainId, hint);
			if (modified) {
				// resource was modified
				// schedule flush of the affected group(s)
				var flushTask = task.postDependentTask(...taskFlushModifiedGroups());
				// also set returned resrefs for rescan and add them to resNode.data.resIdsRefd
				resNode.data.resIdsRefd.clear();
				for (var resRef of resRefs) {
					var subResRefMatch = resRef.match(REGEXP_RESREF),
						subResType = subResRefMatch[1];

					var { resId } = await spTool.client.parseResourceRef(subResType, { data: resRef });
					resNode.data.resIdsRefd.add(resId);
					requestScanResRef(task, { resRef, entry: { data: resRef } });
				}
				
				result = true;
				break;
			}
			result = false; // the resource was not modified
			break;

		case ITEM_RESGRP_PREFIX:
			// do not actually need to build anything here, just refresh the timestamp to the latest of the dependencies
			var node = getNode(nodeId);
			node.data.cacheTS = toFuckingInt(node.data.fileNode.data.cacheTS);
			for (var resId of node.data.resIds) {
				var resNode = getNode(ITEM_RES_PREFIX + resId);
				if (toFuckingInt(resNode.data.cacheTS) > node.data.cacheTS) {
					node.data.cacheTS = toFuckingInt(resNode.data.cacheTS);
				}
			}
			// however, refresh of a group implies re-check on the links node
			requestCheckNode({ nodeId: LINKSJS_NODE_ID, force: "need-check" }).setDependsOn(task.task);
			break;

		case ITEM_LINKSJS_PREFIX:
			// if links set from the links file is different than actual links, rewrite it
			var node = getNode(nodeId),
				actualLinks = getLinksArray(),
				curLinks = await readLinksFile();
			if (!jsonEquals(actualLinks, curLinks)) {
				await writeLinksFile(actualLinks);
				result = true;
			}
			// and consider the TS to be the one of the links file (whether rewritten or not)
			node.data.cacheTS = await filework.fileTimestamp(rootCfg['links-js']);
			break;

		case ITEM_SOURCEHTML_PREFIX:
			// for source HTML, just update the resource timestamp against the file's one,
			// but absence of the file is a build error
			var node = getNode(nodeId),
				ts = await filework.fileTimestamp(rootCfg['source']);
			if (ts == null) {
				throw new Error("Source template file " + rootCfg['source'] + " does not exist");
			}
			node.data.cacheTS = await filework.fileTimestamp(rootCfg['source']);
			result = true;
			break;

		case ITEM_TARGETHTML_PREFIX:
			var node = getNode(nodeId),
				sourceComps = await getSourceHTMLParsed(),
				espinRuntime = await njsFs.promises.readFile(__dirname + njsPath.sep + "espin-runtime.js", "utf8"),
				targetPath = filework.projectPathToRealPath(rootCfg['target']);
			await njsFs.promises.writeFile(targetPath, sourceComps.prologue, { encoding: 'ascii' });
			await njsFs.promises.writeFile(targetPath, "<script>\n" + espinRuntime + "\n</script>",
				{ encoding: "utf8", flag: "a" });
			await njsFs.promises.writeFile(targetPath, "\n<script src=\"" + encodeURI(rootCfg['links-js'].substring(1)) + "\" charset=\"utf-8\"></script>",
				{ encoding: "utf8", flag: "a" });
			await njsFs.promises.writeFile(targetPath, sourceComps.epilogue, { encoding: 'ascii', flag: "a" });
			result = true;
			break;

		case ITEM_FILE_PREFIX:
			var node = getNode(nodeId),
				oldTS = toFuckingInt(node.data.cacheTS),
				ts = await filework.fileTimestamp(node.data.fileProjPath);
			if ((ts === null && oldTS !== null) || ts > oldTS) {
				logDebug("File %s modified - scored as rebuild", node.data.fileProjPath);
				node.data.cacheTS = ts;
				result = true;
			}
			break;
		}
		// after successful rebuild, next one can only occur if the item gets stale
		getNode(nodeId).data.rebuildCause = "Item stale";
		return result;
	}

	async function checkNode(task, { nodeId }) {
		nonFinalTask(task);
		var checkTask = task.task, // myself
			node = getNode(nodeId);

		try {
			// unblock check-deps subtask, become dependent on check-stale and await
			checkTask.data.checkNodeDepsTask.setDependsOn(checkTask.data.checkNodeDepsStart);
			checkTask.setDependsOn(checkTask.data.checkNodeStaleTask);
			checkTask.data.checkNodeDepsStart.unblock();
			await task.untilResumed();

			task.requireSuccessfulDependencies();
		} catch (e) {
			logError("Error in %s: %s", task.taskId, e);
			markFailed(node, e);
			throw e;
		}
	}
	function taskCheckNode(args) { return ["check-node " + args.nodeId, checkNode, args]; }

	async function checkNodeDeps(task, { nodeId }) {
		nonFinalTask(task);
		var [prefix, mainId] = parseNodeId(nodeId),
			node = getNode(nodeId),
			checkTask = task.task.data.checkTask;

		if (!node.data.state) {
			// newly discovered node is considered as to-check
			node.data.state = "need-check";
		}

		if (isResourceNodeToSkipForBuildTest(nodeId)) {
			// resource nodes to-skip are not checked
			node.data.state = "check-stale";
			resNodesToRecheckAfterBuildTest.add(nodeId);
		}

		// repeat it until the dependencies list is stable
		while (node.data.state == "need-check") {
			logDebug("%s: checking dependencies...", nodeId);
			var oldDeps = new Set(node.getDependencyIds()),
				newDeps = await getDeps(task, { nodeId });

			if (!setEquals(oldDeps, newDeps)) {
				logDebug("%s: dependencies changed %s -> %s", nodeId, oldDeps, newDeps);
				for (var oldDep of oldDeps) {
					node.removeDependency(oldDep);
				}
				for (var newDep of newDeps) {
					node.addDependency(newDep);
				}

				// schedule validation task and set it as dependency for our check-stale phase
				checkTask.data.validateDepGraphTask = task.postDependentTask(...taskValidateDepGraph());
				checkTask.data.checkNodeStaleTask.setDependsOn(checkTask.data.validateDepGraphTask);

				// recursive checks of dependencies should also be done, which may result
				// in re-iteration
				for (var newDep of newDeps) {
					var depCheckTask = requestCheckNode({ nodeId: newDep, force: "need-check" });
					task.task.setDependsOn(depCheckTask.data.checkNodeDepsTask);
				}
				await task.untilResumed();
			} else {
				node.data.state = "check-stale";
			}
		}
	}
	function taskCheckNodeDeps(args) { return ["check-node-deps " + args.nodeId, checkNodeDeps, args]; }

	async function checkNodeStale(task, { nodeId }) {
		nonFinalTask(task);
		var node = getNode(nodeId),
			checkTask = task.task.data.checkTask;

		if (isResourceNodeToSkipForBuildTest(nodeId)) {
			// resource nodes to-skip are considered immediately rebuilt
			node.data.state = "stable";
			resNodesToRecheckAfterBuildTest.add(node.id);
			return;
		}

		var depsChanged = !!checkTask.data.validateDepGraphTask;

		// we can only get here if node.data.state == "check-stale", so assuming it

		try {
			task.requireSuccessfulDependencies();

			if (!await isUpToDate(task, { nodeId, depsChanged }) || node.data.isRetry) {
				node.data.isRetry = false;
				(node.data.type == 'file' ? logDebug : logInfo)("%s, updating... %s", node.data.rebuildCause, nodeId);
				node.data.state = "rebuilding";
				var actuallyRebuilt = await rebuild(task, { nodeId, depsChanged });

				if (actuallyRebuilt) {
					if (node.data.type == "tool" && node.data.buildTests.size > 0) {
						logDebug("%s tool node is under build-test, checks propagated in a special way", nodeId);
						// it'll be done by the tool node's resolveJSResIdsRefd
					} else {
						logDebug("%s rebuilt, propagating checks...", nodeId);
						// and then, our dependents need check (unless they are already processed)
						for (var depId of node.getDependentIds()) {
							var depNode = getNode(depId);
							logDebug("propagating check to %s (%s)", depId, depNode.data.state);
							if (depNode.data.state == "stable" || !depNode.data.state) {
								requestCheckNode({ nodeId: depId, force: "need-check" });
							}
						}
					}
				}
			} else {
				logDebug("%s up to date, do not rebuild", nodeId);
			}

			node.data.state = "stable";
		} catch (e) {
			logError("Error in %s: %s", task.taskId, e);
			markFailed(node, e);
			throw e;
		}
	}
	function taskCheckNodeStale(args) { return ["check-node-stale " + args.nodeId, checkNodeStale, args]; }

	var graphValidations = 0;
	async function validateDepGraph(task) {
		nonFinalTask(task);
		var errors = new Array(),
			offendingNodes = depGraph.verifyDepGraph(errors);
		graphValidations++;
		if (offendingNodes.size > 0) {
			for (var error of errors) {
				logError("Error in dependency validation: %s", error);
			}
			offendingNodes.forEach((node) => {
				for (var error of errors) {
					markFailed(node, error);
				}
			});
			throw new Error("Dependency graph validation errors")
		}
	}
	function taskValidateDepGraph(args) { return ["validate-graph #" + graphValidations, validateDepGraph, args]; }

	async function afterFileUpdates(task) {
		nonFinalTask(task);
		logDebug("File updates processing stage finished");
	}
	function taskAfterFileUpdates(args) { return ["after-file-updates", afterFileUpdates, args]; }

	async function afterJS(task) {
		nonFinalTask(task);
		logDebug("JS processing stage finished");
		task.requireSuccessfulDependencies();
	}
	function taskAfterJS(args) { return ["after-js", afterJS, args]; }

	async function afterToolsCfg(task) {
		nonFinalTask(task);
		logDebug("Tools config processing stage finished");
		task.requireSuccessfulDependencies();
	}
	function taskAfterToolsCfg(args) { return ["after-tools-cfg", afterToolsCfg, args]; }

	async function afterTools(task) {
		nonFinalTask(task);
		logDebug("Tools processing stage finished");
		task.requireSuccessfulDependencies();

		if (toolNodesInBuildTest.size <= 0 && resNodesToRecheckAfterBuildTest.size > 0)  {
			logDebug("Refreshing some resource nodes after build-tested tools for consistency");
			for (var resNodeId of resNodesToRecheckAfterBuildTest) {
				requestCheckNode({ nodeId: resNodeId, force: "need-check" });
			}
			resNodesToRecheckAfterBuildTest.clear();
		}
	}
	function taskAfterTools(args) { return ["after-tools", afterTools, args]; }

	async function afterResources(task) {
		nonFinalTask(task);
		logDebug("Resources processing stage finished");
		task.requireSuccessfulDependencies();
	}
	function taskAfterResources(args) { return ["after-res", afterResources, args]; }

	var afterResGroupsCount = 0;
	async function afterResGroups(task) {
		nonFinalTask(task);
		afterResGroupsCount++;

		logDebug("Res groups processing stage finished");
		task.requireSuccessfulDependencies();
	}
	function taskAfterResGroups(args) { return ["after-res-groups #" + afterResGroupsCount, afterResGroups, args]; }

	var groupFlushes = 0;
	async function flushModifiedGroups(task) {
		nonFinalTask(task);
		groupFlushes++;
		task.requireSuccessfulDependencies();
		try {
			ensureToolProcess();
			var affectedItems = await spTool.client.flushModifiedGroups();
			// flushed groups are to be re-checked for deps update
			for (var affectedItem of affectedItems) {
				var resGrpNode = getNodeIfExists(ITEM_RESGRP_PREFIX + affectedItem.groupId);
				if (resGrpNode) {
					requestCheckNode({ nodeId: resGrpNode.id, force: "need-check" });
				}
			}
		} catch (e) {
			logError("Error in %s: %s", task.taskId, e);
			markFailed(node, e);
			throw e;
		}
	}
	function taskFlushModifiedGroups(args) { return ["flush-groups #" + groupFlushes, flushModifiedGroups, args]; }

	async function deleteNodeT(task, { nodeId }) {
		nonFinalTask(task);
		try {
			deleteNode(nodeId);
		} catch (e) {
			logError("Error in %s: %s", task.taskId, e);
			throw e;
		}
	}
	function taskDeleteNodeT(args) { return ["delete-node", deleteNodeT, args]; }

	async function collectUnreachableScripts(task) {
		nonFinalTask(task);
		// this'll be performed regardless on success or failure of dependencies

		var reachedToolIds = new Set(),
			reachedJSIds = new Set();
			nodesScanned = new Set(),
			nodesToScan = new Set();

		// get JS nodes currently reachable from root, they will be "roots" for
		// js/tools reachability checks
		function pickJS(jsNodeId) {
			var node = depGraph.getNode(jsNodeId);
			if (nodesToScan.has(node) || !node.data.fileNode) {
				return; // already counted, or it is a raw file node to skip
			}

			var localFilework = filework.pathGetterRelToProjFilePath(node.data.fileNode.data.fileProjPath);

			reachedJSIds.add(jsNodeId);
			for (var depJSNodeId of node.getDependencyIds()) {
				pickJS(depJSNodeId);
			}
			nodesToScan.add(node);
			reachedJSIds.add(jsNodeId);

			if (node.data.toolsDeclared) {
				for (var tool of node.data.toolsDeclared) {
					var actualFileName = localFilework.fileNameToProjPath(tool.args[0]);
					reachedToolIds.add(ITEM_TOOL_PREFIX + actualFileName);
				}
			}
		}
		pickJS(ITEM_ROOT_PREFIX + rootProjPath);

		// find out which JS and tools remained unreachable and remove the nodes
		for (var jsNodeId of jsNodeIds) {
			if (!reachedJSIds.has(jsNodeId)) {
				logInfo("Unreachable JS %s - remove", jsNodeId);
				deleteNode(jsNodeId);
			}
		}

		for (var toolNodeId of toolNodeIds) {
			if (!reachedToolIds.has(toolNodeId)) {
				logInfo("Unreachable tool %s - remove", toolNodeId);
				deleteNode(toolNodeId);
			}
		}
	}
	function taskCollectUnreachableScripts(args) { return ["collect-unrechable-scripts", collectUnreachableScripts, args]; }

	async function finalizeSpin(task) {
		logInfo("Finalizing spin...");
		// TODO: print summary on incomplete items
	}
	function taskFinalizeSpin(args) { return ["finalize-spin", finalizeSpin, args]; }
	function nonFinalTask(task) {
		task.postDependentTask(...taskFinalizeSpin());
	}
	// in this version 'task' is a task, not a task hanle
	function setNonFinalTask(task) {
		var finalizeSpinTask = depTaskDoer.postTask(...taskFinalizeSpin());
		finalizeSpinTask.setDependsOn(task);
	}

	function listReachableResources() {
		var resIds = new Set(),
			nodesScanned = new Set(),
			nodesToScan = new Set();

		// get JS nodes currently reachable from root, they will be "roots" for
		// resource reachability checks
		function pickJS(jsNodeId) {
			var node = depGraph.getNode(jsNodeId);
			if (nodesToScan.has(node) || !node.data.fileNode) {
				return; // already counted, or it is a raw file node to skip
			}
			for (var depJSNodeId of node.getDependencyIds()) {
				pickJS(depJSNodeId);
			}
			nodesToScan.add(node);
		}
		pickJS(ITEM_ROOT_PREFIX + rootProjPath);

		// now scan the resIdsRefd, starting from the JS nodes and in-deep
		for (;;) {
			var nodesUnderScan = nodesToScan;
			nodesToScan = new Set();
			if (nodesUnderScan.size <= 0) break;

			for (var node of nodesUnderScan) {
				nodesScanned.add(node);
				if (node.data.resIdsRefd) {
					for (var resId of node.data.resIdsRefd) {
						resIds.add(resId);
						var resNodeId = ITEM_RES_PREFIX + resId,
							resNode = getNodeIfExists(resNodeId);
						if (resNode && !nodesScanned.has(resNode)) {
							nodesToScan.add(resNode);
						}
					}
				}
			}
		}

		return resIds;
	}

	// return: true if any nodes have been affected
	async function pruneUnusedResources() {
		var resGroupIds = new Set();
		for (var resGroupNodeId of resGroupNodeIds) {
			resGroupIds.add(getNode(resGroupNodeId).data.resGroupId);
		}
		var usedResIds = listReachableResources();
		ensureToolProcess();
		var { prunedResIds, prunedResGroupIds, groupIdsChanged } = await spTool.client.cleanUnusedResources(resGroupIds, usedResIds);

		// delete nodes of the pruned resources and resource groups
		for (var resId of prunedResIds) {
			deleteNode(ITEM_RES_PREFIX + resId);
		}
		for (var resGroupId of prunedResGroupIds) {
			deleteNode(ITEM_RESGRP_PREFIX + resGroupId);
		}

		if (prunedResIds.size > 0) {
			logInfo(prunedResIds.size + " unused resources pruned from compiled group files: " + [...prunedResIds]);
		}
		if (prunedResGroupIds.size > 0) {
			logInfo(prunedResGroupIds.size + " emptied groups and compiled group files pruned: " + [...prunedResGroupIds]);
		}
		return { prunedResIds, prunedResGroupIds, groupIdsChanged };
	}

	async function buildRelease() {
		var links = getLinksArray(true),
			sourceComps = await getSourceHTMLParsed(),
			espinRuntime = await njsFs.promises.readFile(__dirname + njsPath.sep + "espin-runtime.js", "utf8");
		if (spTool) {
			spTool.close();
			spTool = null;
		}
		ensureToolProcess(); // re-open the subprocess to clean up the spin related caches
		try {
			await spTool.client.rewriteReleaseTargetFile(sourceComps.prologue);
			await spTool.client.appendStringToReleaseTargetFile("<script>\n" + espinRuntime + "</script>");
			for (var link of links) {
				var ts = Date.now();
				await spTool.client.appendStringToReleaseTargetFile("\n<script>");
				await spTool.client.appendFileToReleaseTargetFile(link.file, link.iconvCharset, true);
				await spTool.client.appendStringToReleaseTargetFile("</script>");
			}
			await spTool.client.appendStringToReleaseTargetFile(sourceComps.epilogue);
			await spTool.client.closeReleaseTargetFile();
		} catch (e) {
			await spTool.client.closeReleaseTargetFile();
			throw e;
		}
	}

	return (me = {
		depGraph,
		async perform(commands = new Set()) {
			if (!depTaskDoer.isPerformInProgress) {
				// on each new perform, add the nodes marked for extra check at previous perform
				for (var node of extraNodesToCheckOnNextPerform) {
					node.data.isRetry = true;
					// the node is in "failed" state from previous attempt - resest it to re-enable node check request
					node.data.state = "need-check"; 
					requestCheckNode({ nodeId: node.id, force: "need-check" });
				}
				extraNodesToCheckOnNextPerform.clear();
			}
			try {
				itemsInError = new Map();
				nodeIdsDeletedThisRespin.clear();
				await depTaskDoer.perform();
				// clearing the check task and checkpoint task pads only here,
				// because we can be requesting more check nodes in between the performs,
				// and this should be treated as "before" next perform - hence need to reset this part of the state
				// prior to any extra check requests
				nodeCheckTasks = new Object();
				checkpointTasks = null;

				for (;;) {
					if (itemsInError.size > 0) {
						logInfo(itemsInError.size,
							"items in error after the spin, no release or prune is possible until the issues are resolved");
						return itemsInError;
					} else if (toolNodesInBuildTest.size > 0) {
						logInfo("All items ok, but some tools contain #build-test - release and prune blocked to prevent inconsistent result");
						logInfo("Tools under test: " + [...toolNodesInBuildTest]);
						return itemsInError;
					} else {
						logInfo("All items ok, release and prune are possible");
					}

					if (commands.has('prune')) {
						logInfo("Performing prune iteration...");
						var pruneResult = await pruneUnusedResources();
						if (pruneResult.prunedResIds.size + pruneResult.prunedResGroupIds.size + pruneResult.groupIdsChanged.size > 0) {
							// affected (but not deleted) groups are to be re-checked for deps update
							for (var affectedGroupId of pruneResult.groupIdsChanged) {
								var resGrpNode = getNodeIfExists(ITEM_RESGRP_PREFIX + affectedGroupId);
								if (resGrpNode) {
									requestCheckNode({ nodeId: resGrpNode.id, force: "need-check" });
								}
							}
							continue; // respin after each prune until no more changes occur
						} else {
							logInfo("Prune completed");
						}
					}

					break;
				}

				if (commands.has('release')) {
					logInfo("Building release (<project-root>:" + rootCfg["release-target"] + ")...");
					await buildRelease();
					logInfo("Release built!");
				}

				return itemsInError;
			} finally {
				if (spTool) {
					spTool.close();
					spTool = null;
				}
			}
		},
		get isPerformInProgress() {
			return depTaskDoer.isPerformInProgress;
		},
		addCheckRoots() {
			requestCheckNode({ nodeId: ITEM_ROOT_PREFIX + rootProjPath, force: "need-check" });
			requestCheckNode({ nodeId: TARGETHTML_NODE_ID, force: "need-check" });
		},
		addCheckNode(nodeId, isFileUpdate) {
			var node = getNodeIfExists(nodeId);
			if (node) {
				requestCheckNode({ nodeId, force: "need-check", isFileUpdate });
			}
		},
		getKnownNodeIdsByProjPaths(fileProjPaths) {
			var knownNodes = new Set(), nodeName;
			for (var fileProjPath of fileProjPaths) {
				if (fileProjPath == rootProjPath) {
					nodeName = ITEM_ROOT_PREFIX + rootProjPath;
				} else if (fileProjPath == rootCfg["source"]) {
					nodeName = SOURCEHTML_NODE_ID;
				} else if (fileProjPath == rootCfg["target"]) {
					nodeName = TARGETHTML_NODE_ID;
				} else if (fileProjPath == rootCfg["links-js"]) {
					nodeName = LINKSJS_NODE_ID;
				} else if (fileProjPath == rootCfg["default-resgroup-js"]) {
					nodeName = ITEM_RESGRP_PREFIX + "";
				} else {
					nodeName = ITEM_FILE_PREFIX + fileProjPath;
				}

				if (getNodeIfExists(nodeName)) {
					knownNodes.add(nodeName);
				}
			}

			return knownNodes;
		},
		getKnownFileNodeIdsByProjPaths(fileProjPaths) {
			var knownNodes = new Set();
			for (var fileProjPath of fileProjPaths) {
				var nodeName = ITEM_FILE_PREFIX + fileProjPath;
				if (getNodeIfExists(nodeName)) {
					knownNodes.add(nodeName);
				}
			}

			return knownNodes;
		},
		logError,
		logInfo,
		logDebug,
		get noStdErr() { return noStdErr; },
		set noStdErr(val) { noStdErr = val; },
		async reopenLogFile(path) {
			if (!path) {
				path = filework.projectPathToRealPath(rootProjPathNoExt + ".es-last-spin.log");
			}
			if (logFileStream) {
				try {
					var finished = Future();
					for (var evt of ['error', 'close']) {
						logFileStream.on(evt, () => finished.resolve());
					}
					logFileStream.end();
					await finished;
				} catch (e) {
					logError("WARNING: failed to close stream %s: %s", logFileStreamPath, e);
				}
				logFileStream = null;
				
			}
			logFileStreamPath = path;
			try {
				await njsFs.promises.truncate(logFileStreamPath, 0);
			} catch (e) {
				logError("WARNING: failed to truncate stream %s", logFileStreamPath);
			}
			logFileStream = njsFs.createWriteStream(path);
			
			logFileStream.write(util.format("=== %s Restarting the last spin log ===\n", new Date().toLocaleTimeString()));
		}
	});
};
