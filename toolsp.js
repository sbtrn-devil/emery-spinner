const TOOLKIT_API_VERSION = "1.0.0";

const util = require('util'),
	njsFs = require('fs'),
	iconvlite = require('iconv-lite'),
	pako = require('pako'),
	{ runServer } = require('./subprocess.js'),
	{ Filework } = require('./filework.js'),
	{ WrappedJSON } = require('./wrapped-json.js'),
	{ Future } = require('./future.js');

const REGEXP_RESREF = /^#([-A-Za-z0-9._\(\)\[\]\{\}$%!]+)@/,
	REGEXP_STD_RESREF = /^#([-A-Za-z0-9._\(\)\[\]\{\}$%!]+)@((?:[^\/]*\/)*)([^\/:]*)(?:(?::)([\S\s]*))?$/,
	REGEXP_STD_GROUP_SLASH_TRIM = /(^\/+)|(\/+$)/g,
	REGEXP_GROUP_FILE_BASENAME = /^(\/.*)?(?:\.es-gen\.js)?$/i,
	ITEM_FILE_PREFIX = "file:",
	ITEM_RES_PREFIX = "res:";

function jsonEquals(a, b) {
	if (a === b) return true;
	if (typeof(a) !== 'object' || typeof(b) !== 'object') {
		return a === b;
	}
	for (var k in a) {
		if (!(k in b)) return false;
		if (!jsonEquals(a[k], b[k])) return false;
	}
	for (var k in b) {
		if (!(k in a)) return false;
		if (!jsonEquals(b[k], a[k])) return false;
	}
	return true;
}

var server, serverCtl, filework, defaultGroupPath, toolByResType, rootCfg, toolsCfg;
var parsedResRefCache = new Object(), // results of parseResourceRef
	// resIds of resources allowed for reading from builder of given resource IDs
	allowedResIdsPerResId = new Object(),
	// proj paths of files allowed for reading from builder of given resource IDs
	allowedFilesPerResId = new Object(),
	resTypesToSkipForBuildTest;

const groupWrappedJSON = WrappedJSON({
		prologue: "// Resource group file generated by emery-spinner, don't edit outside JSON part below\n" +
			"_EmerySpinnerRuntime_.addResources(",
		beginFragment: "//--edit-below-json-only-utf8-<",
		endFragment: "//>--edit-above-json-only-utf8",
		epilogue: ");\n// TODO: progress indicator\n_EmerySpinnerRuntime_.asyncRemoveCurrentScript();"
	});

function logErrorWithSource(source, data, ...args) {
	serverCtl.processSendMsg({
		log: "error",
		source,
		msg: util.format(data, ...args)
	});
}

function logError(data, ...args) {
	logErrorWithSource("", data, ...args);
}

function logInfoWithSource(source, data, ...args) {
	serverCtl.processSendMsg({
		log: "info",
		source,
		msg: util.format(data, ...args)
	});
}

function logInfo(data, ...args) {
	logInfoWithSource("", data, ...args);
}

function logDebugWithSource(source, data, ...args) {
	serverCtl.processSendMsg({
		log: "debug",
		source,
		msg: util.format(data, ...args)
	});
}

function logDebug(data, ...args) {
	logDebugWithSource("", data, ...args);
}

const GROUP_MODIFIED = Symbol();
var resGroupCache = new Object(), // group ID => { resId: ..., [GROUP_MODIFIED]: true|false }
	resGroupByResId = new Object(), // resId => groupId
	resGroupChanged = new Object(); // group ID => true

function getGroupFileName(resGroupId) {
	if (resGroupId == "") {
		// default group's ("") filename is specified by the project root config
		return rootCfg['default-resgroup-js'];
	} else {
		// other groups file names are the group ids suffixed by .es-gen.js
		return resGroupId + ".es-gen.js";
	}
}

async function ensureResGroupCached(resGroupId) {
	if (resGroupCache[resGroupId]) {
		return; // already cached
	}

	// otherwise, determine the file name and read it from there...
	var groupFileName = getGroupFileName(resGroupId);

	try {
		var group = await groupWrappedJSON.read(filework.projectPathToRealPath(groupFileName));
		if (typeof(group) !== 'object' || Array.isArray(group)) {
			throw Error("Resource group must be a JSON object (key-value dictionary)");
		}
		resGroupCache[resGroupId] = group;
	} catch (e) {
		if (e.code == 'ENOENT') {
			// no file equals to empty group
			resGroupCache[resGroupId] = new Object();
		} else {
			throw e;
		}
	}
}

async function ensureResCached(resId) {
	var resGroupId = resGroupByResId[resId];
	if (typeof(resGroupId) !== 'string') {
		// this should normally not happen, regardless on user's mistakes, but signal it just in case
		throw Error("Used resource " + JSON.stringify(resId) + " before defining a group for it!");
	}

	await ensureResGroupCached(resGroupId);
}

const SAVE_TARGET = Symbol();

function makeToolkit(resId, resType, editable) {
	function isFileAllowed(projPath) {
		return resId && allowedFilesPerResId[resId].has(projPath);
	}

	function isResourceAllowed(resRef) {
		// res ref converts to res ID
		return resId && resRef &&
			parsedResRefCache[resRef] && // if didn't yet get into the cache -> wasn't declared as dependency -> not allowed
			(allowedResIdsPerResId[resId].has(parsedResRefCache[resRef].resId) ||
				parsedResRefCache[resRef].resId == resId); // access to self is always allowed
	}

	var logSource = resType || "",
		resTarget;

	return {
		apiVersion: TOOLKIT_API_VERSION,
		logError: logErrorWithSource.bind(this, logSource),
		logInfo: logInfoWithSource.bind(this, logSource),
		logDebug: logDebugWithSource.bind(this, logSource),
		parseStdResRef(resRef) {
			if (typeof (resRef) != 'string') return null;
			var match = resRef.match(REGEXP_STD_RESREF);
			if (!match) return null;
			return {
				type: match[1],
				dirPath: "/" + match[2].replace(REGEXP_STD_GROUP_SLASH_TRIM, ""),
				name: match[3] || "",
				hint: match[4] || "",
				get projectPath() { return this.dirPath + (this.dirPath == "/"? "" : "/") + this.name; },
				get group() { return this.dirPath == "/" ? "" : this.dirPath; },
				get resId() { return "#" + this.type + "@" + this.projectPath; }
			};
		},
		isFileAllowed(projPath) {
			return isFileAllowed(projPath);
		},
		getFileRealPath(projPath) {
			if (!isFileAllowed(projPath)) {
				throw Error("Access to file " + projPath + " is not granted in this context");
			}

			return filework.projectPathToRealPath(projPath);
		},
		async getFileTimestamp(projPath) {
			if (!isFileAllowed(projPath)) {
				throw Error("Access to file " + projPath + " is not granted in this context");
			}

			return await filework.fileTimestamp(projPath);
		},
		isResourceAllowed(resRef) {
			return isResourceAllowed(resRef);
		},
		async getResource(resRef) {
			if (!isResourceAllowed(resRef)) throw Error("Access to resource " + resRef + " is not granted in this context");
			var actResId = parsedResRefCache[resRef].resId;
			await ensureResCached(actResId);
			if (editable && actResId == resId) {
				// it is the subject resource and editis enabled (i. e. build mode) - construct target for it
				if (!resTarget) {
					resTarget = Object.assign(JSON.parse(JSON.stringify(resGroupCache[resGroupByResId[actResId]][actResId] || {})));
				}
				return resTarget;
			} else {
				// read-only proxy
				var target = resGroupCache[resGroupByResId[actResId]][actResId] || {};
				return new Proxy(target, {
					get(target, prop, receiver) {
						return Reflect.get(target, prop, receiver);
					},
					set(target, prop, value) {
						throw new Error("Resource " + resRef + (resRef == actResId ? " [" : " (" + actResId +") [") + prop + "] is not writable in this context");
					},
					deleteProperty(target, prop) {
						throw new Error("Resource " + resRef + (resRef == actResId ? " [" : " (" + actResId +") [") + prop + "] is not writable in this context");
					},
					ownKeys(target) {
						return Reflect.ownKeys(target);
					},
					has(target, prop) {
						return Reflect.has(target, prop);
					}
				});
			}
		},
		getToolsConfig(keyId) {
			return toolsCfg[keyId];
		},
		clearObjectProperties(target) {
			Object.keys(target).forEach(key => delete target[key]);
		},
		// save resRef to group cache, return the json-purified resource if modified, or false if not
		async [SAVE_TARGET]() {
			if (!resTarget) return false; // the resource was not accessed, nothing to do
			var resTargetPurified = JSON.parse(JSON.stringify(resTarget));
			if (!jsonEquals(resGroupCache[resGroupByResId[resId]][resId], resTargetPurified)) {
				var groupCache = resGroupCache[resGroupByResId[resId]];
				groupCache[resId] = resTargetPurified;
				groupCache[GROUP_MODIFIED] = true;
				return resTargetPurified;
			}
			return false;
		}
	};
}

async function scanResRefs(resId, skipTestable = false) {
	var result = new Set(), wereSkips = false;
	async function scanNested(obj, level) {
		for (var k in obj) {
			var v = obj[k];
			switch (typeof(v)) {
			case 'object': await scanNested(v, level + 1); break;
			case 'string':
				var match = v.match(REGEXP_RESREF);
				if (match) {
					// a res ref - correct it to res ID and add to the list
					var resType = match[1];
					if (skipTestable && level > 0 && resTypesToSkipForBuildTest.has(resType)) {
						wereSkips = true;
						break;
					}

					var parsedRef = await server.parseResourceRef(resType, { data: v });
					obj[k] = parsedRef.resId;
					result.add(v);
				}
				break;
			}
		}
	}

	await ensureResCached(resId);
	var resGroupId = resGroupByResId[resId];
	await scanNested(resGroupCache[resGroupId][resId] || {}, 0);
	return { wereSkips, result };
}

var releaseWriteStream; // used by *ReleaseTargetFile methods

function checkToolInitialized(tool, resType) {
	if (tool instanceof Error) {
		var error = new Error("Tool for resource type " + resType + " failed to initialize");
		error.cause = tool;
		throw error;
	}
}

serverCtl = runServer(server = {
	async initialize(rootFilePath, defaultGroupPath, tools, rootCfgUpd, toolsCfgUpd, resTypesToSkipForBuildTestUpd) {
		filework = new Filework(rootFilePath);
		toolByResType = new Object();
		rootCfg = rootCfgUpd;
		toolsCfg = toolsCfgUpd;
		resTypesToSkipForBuildTest = resTypesToSkipForBuildTestUpd;
		var errors = 0;
		for (var resType in tools) {
			try {
				var toolInfo = tools[resType],
					tool = (toolByResType[resType] = require(toolInfo.toolPath)[resType]);
				if (tool.init) {
					var toolkit = makeToolkit(null, resType);
					await tool.init({ toolkit });
				}
			} catch (e) {
				if (e instanceof Error) {
					toolByResType[resType] = e;
				} else {
					toolByResType[resType] = new Error("Error initializing tool for resource type " + resType + ": " + e);
				}
				logError(e);
				errors++;
			}
		}

		if (errors > 0) {
			throw Error(errors + " in tool subprocess");
		}
	},

	async parseResourceRef(resType, resRef) {
		if (parsedResRefCache[resRef.data]) return parsedResRefCache[resRef.data];
		var tool = toolByResType[resType];
		if (!tool) {
			throw Error("Can't parse resource ref string " + JSON.stringify(resRef.data) + " - no valid tool for resource type " + JSON.stringify(resType));
		}
		checkToolInitialized(tool, resType);
		var result = await tool.parseResourceRef({
			resRef: resRef.data,
			toolkit: makeToolkit(null, resType) });
		if (!result.resId.startsWith("#" + resType + "@")) {
			throw Error("Resource ID parsed from ref string " + JSON.stringify(resRef.data) + " must start from #" + resType + "@, but got " +
				JSON.stringify(result.resId));
		}
		if (typeof(result.group) !== 'string' || !result.group.match(REGEXP_GROUP_FILE_BASENAME)) {
			throw Error("Invalid or unspecified group for resource ID " + JSON.stringify(result.resId) + ": single-line string, empty or starting with '/', expected, but got " +
				JSON.stringify(result.group));
		}
		parsedResRefCache[resRef.data] = result;
		resGroupByResId[result.resId] = result.group;
		return result;
	},

	async getBuildDependencies(resType, resId) {
		var tool = toolByResType[resType];
		checkToolInitialized(tool, resType);

		allowedResIdsPerResId[resId] = allowedResIdsPerResId[resId] || new Set();
		allowedFilesPerResId[resId] = allowedFilesPerResId[resId] || new Set();
		var deps = await tool.getBuildDependencies({
			resId,
			toolkit: makeToolkit(resId, resType) }),
			result = new Set();
		// the dependency getter resets the list of allowed resources and files
		allowedResIdsPerResId[resId] = new Set();
		allowedFilesPerResId[resId] = new Set();
		for (var dep of deps) {
			var resMatch = dep.match(REGEXP_RESREF);
			if (resMatch) {
				// it matches res ref format, hence it is a res ref
				var resType = resMatch[1],
					depResId = await server.parseResourceRef(resType, dep);
				result.add(ITEM_RES_PREFIX + depResId.resId);
				allowedResIdsPerResId[resId].add(depResId);
			} else {
				// otherwise it is a file - should be a project root relative path
				if (dep[0] != '/') {
					throw Error("File dependency " + dep + " should be in project-root relative path format");
				}
				result.add(ITEM_FILE_PREFIX + dep);
				allowedFilesPerResId[resId].add(dep);
			}
		}
		return [...result];
	},

	async isResourceUpToDate(resType, resId, hint) {
		var tool = toolByResType[resType];
		checkToolInitialized(tool, resType);

		await server.parseResourceRef(resType, { data: resId }); // to ensure it is assigned a group
		var toolkit = makeToolkit(resId, resType), scanRes;
		return {
			isUpToDate: await tool.isResourceUpToDate({
				resId,
				hint,
				target: await toolkit.getResource(resId),
				toolkit
			}),
			resRefs: [...(scanRes = await scanResRefs(resId, true), scanRes.result)],
			wereSkips: scanRes.wereSkips
		};
	},

	async rebuildResource(resType, resId, hint) {
		var tool = toolByResType[resType];
		checkToolInitialized(tool, resType);

		await server.parseResourceRef(resType, { data: resId });
		var toolkit = makeToolkit(resId, resType, true);
		await tool.rebuildResource({
			resId,
			hint,
			target: await toolkit.getResource(resId),
			toolkit
		});
		var modifiedRes = await toolkit[SAVE_TARGET]();
		return {
			modified: modifiedRes,
			resRefs: [...(await scanResRefs(resId)).result]
		};
	},

	async flushModifiedGroups() {
		var affectedItems = new Array();
		for (var groupId in resGroupCache) {
			var group = resGroupCache[groupId];
			if (group[GROUP_MODIFIED]) {
				var
					groupFileName = getGroupFileName(groupId),
					groupRealFileName = filework.projectPathToRealPath(groupFileName);
				logDebug("Group", groupId || "[default]", "MODIFIED, saving to file", groupRealFileName);
				await groupWrappedJSON.write(groupRealFileName, group);
				group[GROUP_MODIFIED] = false;
				affectedItems.push({ groupId, groupFileName });
			}
		}

		return affectedItems;
	},

	async rewriteReleaseTargetFile(prologue) {
		var targetPath = filework.projectPathToRealPath(rootCfg["release-target"]),
			done = Future();
		releaseWriteStream = njsFs.createWriteStream(targetPath);
		releaseWriteStream.write(prologue, "utf8", done.callback);
		await done;
	},

	async appendStringToReleaseTargetFile(str) {
		var targetPath = filework.projectPathToRealPath(rootCfg["release-target"]),
			done = Future();
		releaseWriteStream.write(str, "utf8", done.callback);
		await done;
	},

	async appendFileToReleaseTargetFile(projPath, iconvCharset, wrap) {
		var sourcePath = filework.projectPathToRealPath(projPath),
			targetPath = filework.projectPathToRealPath(rootCfg["release-target"]),
			source = iconvlite.decode(await njsFs.promises.readFile(sourcePath), iconvCharset),
			done = Future();
		if (wrap) {
			var pakoSrc = "/*" + projPath + "*/" + '_EmerySpinnerRuntime_.zEmit("' + Buffer.from(pako.deflate(Buffer.from(source, 'utf8'))).toString('base64') + '");',
				uncompressedSrc = "/*" + projPath + "*/" + '_EmerySpinnerRuntime_.emit(' + JSON.stringify(source).replace(/[\u007F-\uFFFF]/g, function(chr) {
				    return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).substr(-4)
				}) +');',
				source = pakoSrc.length < uncompressedSrc.length ? pakoSrc : uncompressedSrc; // write whatever version is the shortest
		}
		releaseWriteStream.write(source, "utf8", done.callback);
		await done;
	},

	async closeReleaseTargetFile() {
		if (releaseWriteStream) {
			var done = Future();
			releaseWriteStream.on('finish', () => { done.resolve(); });
			releaseWriteStream.close();
			releaseWriteStream = null;
			await done;
		}
	},

	async cleanUnusedResources(resGroupIds, usedResIds) {
		var resIdsToDrop = new Set(),
			groupIdsToDrop = new Set(),
			groupIdsChanged = new Set(); // will not include groupIdsToDrop
		for (var resGroupId of resGroupIds) {
			await ensureResGroupCached(resGroupId);
			var group = resGroupCache[resGroupId],
				resIdsRemaining = 0,
				resIdsDropped = new Array();
			for (var resId in group) {
				if (!usedResIds.has(resId)) {
					resIdsToDrop.add(resId);
					resIdsDropped.push(resId);
					groupIdsChanged.add(resGroupId);
				} else {
					resIdsRemaining++;
				}
			}

			if (resIdsDropped.length) {
				for (var resId of resIdsDropped) {
					delete group[resId];
				}
				group[GROUP_MODIFIED] = true;
			}

			if (resIdsRemaining <= 0 && resGroupId != "") {
				// if the group ends up empty, delete it from the group cache and delete the group file
				groupIdsToDrop.add(resGroupId);
				groupIdsChanged.delete(resGroupId);
				delete resGroupCache[resGroupId];
				await njsFs.promises.unlink(filework.projectPathToRealPath(getGroupFileName(resGroupId)));
			}
		}

		if (resIdsToDrop.size > 0) {
			await server.flushModifiedGroups();
		}

		return { prunedResIds: resIdsToDrop, prunedResGroupIds: groupIdsToDrop, groupIdsChanged };
	}
});